import { computed, Inject, Injectable, Optional } from '@angular/core';
import { of, throwError, catchError, distinctUntilChanged, map, shareReplay, take } from 'rxjs';
import { ɵINITIAL_STATE_TOKEN, ɵStateStream } from '@ngxs/store/internals';
import { InternalNgxsExecutionStrategy } from './execution/internal-ngxs-execution-strategy';
import { InternalStateOperations } from './internal/state-operations';
import { getRootSelectorFactory } from './selectors/selector-utils';
import { leaveNgxs } from './operators/leave-ngxs';
import { NgxsConfig } from './symbols';
import { StateFactory } from './internal/state-factory';
import * as i0 from "@angular/core";
import * as i1 from "@ngxs/store/internals";
import * as i2 from "./internal/state-operations";
import * as i3 from "./symbols";
import * as i4 from "./execution/internal-ngxs-execution-strategy";
import * as i5 from "./internal/state-factory";
const NG_DEV_MODE = typeof ngDevMode !== 'undefined' && ngDevMode;
export class Store {
    constructor(_stateStream, _internalStateOperations, _config, _internalExecutionStrategy, _stateFactory, initialStateValue) {
        this._stateStream = _stateStream;
        this._internalStateOperations = _internalStateOperations;
        this._config = _config;
        this._internalExecutionStrategy = _internalExecutionStrategy;
        this._stateFactory = _stateFactory;
        /**
         * This is a derived state stream that leaves NGXS execution strategy to emit state changes within the Angular zone,
         * because state is being changed actually within the `<root>` zone, see `InternalDispatcher#dispatchSingle`.
         * All selects would use this stream, and it would call leave only once for any state change across all active selectors.
         */
        this._selectableStateStream = this._stateStream.pipe(leaveNgxs(this._internalExecutionStrategy), shareReplay({ bufferSize: 1, refCount: true }));
        this.initStateStream(initialStateValue);
    }
    /**
     * Dispatches action(s).
     */
    dispatch(actionOrActions) {
        if (NG_DEV_MODE) {
            if (
            // If a single action is dispatched and it's nullable.
            actionOrActions == null ||
                // If a list of actions is dispatched and any of the actions are nullable.
                (Array.isArray(actionOrActions) && actionOrActions.some(action => action == null))) {
                const error = new Error('`dispatch()` was called without providing an action.');
                return throwError(() => error);
            }
        }
        return this._internalStateOperations.getRootStateOperations().dispatch(actionOrActions);
    }
    /**
     * Selects a slice of data from the store.
     */
    select(selector) {
        const selectorFn = this.getStoreBoundSelectorFn(selector);
        return this._selectableStateStream.pipe(map(selectorFn), catchError((error) => {
            // if error is TypeError we swallow it to prevent usual errors with property access
            if (this._config.selectorOptions.suppressErrors && error instanceof TypeError) {
                return of(undefined);
            }
            // rethrow other errors
            return throwError(error);
        }), distinctUntilChanged(), leaveNgxs(this._internalExecutionStrategy));
    }
    /**
     * Select one slice of data from the store.
     */
    selectOnce(selector) {
        return this.select(selector).pipe(take(1));
    }
    /**
     * Select a snapshot from the state.
     */
    selectSnapshot(selector) {
        const selectorFn = this.getStoreBoundSelectorFn(selector);
        return selectorFn(this._stateStream.getValue());
    }
    /**
     * Select a signal from the state.
     */
    selectSignal(selector) {
        const selectorFn = this.getStoreBoundSelectorFn(selector);
        return computed(() => selectorFn(this._stateStream.state()));
    }
    /**
     * Allow the user to subscribe to the root of the state
     */
    subscribe(fn) {
        return this._selectableStateStream
            .pipe(leaveNgxs(this._internalExecutionStrategy))
            .subscribe(fn);
    }
    /**
     * Return the raw value of the state.
     */
    snapshot() {
        return this._internalStateOperations.getRootStateOperations().getState();
    }
    /**
     * Reset the state to a specific point in time. This method is useful
     * for plugin's who need to modify the state directly or unit testing.
     */
    reset(state) {
        this._internalStateOperations.getRootStateOperations().setState(state);
    }
    getStoreBoundSelectorFn(selector) {
        const makeSelectorFn = getRootSelectorFactory(selector);
        const runtimeContext = this._stateFactory.getRuntimeSelectorContext();
        return makeSelectorFn(runtimeContext);
    }
    initStateStream(initialStateValue) {
        const value = this._stateStream.value;
        const storeIsEmpty = !value || Object.keys(value).length === 0;
        if (storeIsEmpty) {
            this._stateStream.next(initialStateValue);
        }
    }
    /** @nocollapse */ static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.6", ngImport: i0, type: Store, deps: [{ token: i1.ɵStateStream }, { token: i2.InternalStateOperations }, { token: i3.NgxsConfig }, { token: i4.InternalNgxsExecutionStrategy }, { token: i5.StateFactory }, { token: ɵINITIAL_STATE_TOKEN, optional: true }], target: i0.ɵɵFactoryTarget.Injectable }); }
    /** @nocollapse */ static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.0.6", ngImport: i0, type: Store, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.6", ngImport: i0, type: Store, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: () => [{ type: i1.ɵStateStream }, { type: i2.InternalStateOperations }, { type: i3.NgxsConfig }, { type: i4.InternalNgxsExecutionStrategy }, { type: i5.StateFactory }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [ɵINITIAL_STATE_TOKEN]
                }] }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RvcmUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9wYWNrYWdlcy9zdG9yZS9zcmMvc3RvcmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLEVBQUUsVUFBVSxFQUFFLFFBQVEsRUFBVSxNQUFNLGVBQWUsQ0FBQztBQUMvRSxPQUFPLEVBRUwsRUFBRSxFQUVGLFVBQVUsRUFDVixVQUFVLEVBQ1Ysb0JBQW9CLEVBQ3BCLEdBQUcsRUFDSCxXQUFXLEVBQ1gsSUFBSSxFQUNMLE1BQU0sTUFBTSxDQUFDO0FBQ2QsT0FBTyxFQUFFLG9CQUFvQixFQUFFLFlBQVksRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBRTNFLE9BQU8sRUFBRSw2QkFBNkIsRUFBRSxNQUFNLDhDQUE4QyxDQUFDO0FBQzdGLE9BQU8sRUFBRSx1QkFBdUIsRUFBRSxNQUFNLDZCQUE2QixDQUFDO0FBQ3RFLE9BQU8sRUFBRSxzQkFBc0IsRUFBRSxNQUFNLDRCQUE0QixDQUFDO0FBQ3BFLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUNuRCxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sV0FBVyxDQUFDO0FBQ3ZDLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQzs7Ozs7OztBQUd4RCxNQUFNLFdBQVcsR0FBRyxPQUFPLFNBQVMsS0FBSyxXQUFXLElBQUksU0FBUyxDQUFDO0FBU2xFLE1BQU0sT0FBTyxLQUFLO0lBV2hCLFlBQ1UsWUFBMEIsRUFDMUIsd0JBQWlELEVBQ2pELE9BQW1CLEVBQ25CLDBCQUF5RCxFQUN6RCxhQUEyQixFQUduQyxpQkFBc0I7UUFQZCxpQkFBWSxHQUFaLFlBQVksQ0FBYztRQUMxQiw2QkFBd0IsR0FBeEIsd0JBQXdCLENBQXlCO1FBQ2pELFlBQU8sR0FBUCxPQUFPLENBQVk7UUFDbkIsK0JBQTBCLEdBQTFCLDBCQUEwQixDQUErQjtRQUN6RCxrQkFBYSxHQUFiLGFBQWEsQ0FBYztRQWZyQzs7OztXQUlHO1FBQ0ssMkJBQXNCLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQ3JELFNBQVMsQ0FBQyxJQUFJLENBQUMsMEJBQTBCLENBQUMsRUFDMUMsV0FBVyxDQUFDLEVBQUUsVUFBVSxFQUFFLENBQUMsRUFBRSxRQUFRLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FDL0MsQ0FBQztRQVlBLElBQUksQ0FBQyxlQUFlLENBQUMsaUJBQWlCLENBQUMsQ0FBQztJQUMxQyxDQUFDO0lBRUQ7O09BRUc7SUFDSCxRQUFRLENBQUksZUFBMEM7UUFDcEQsSUFBSSxXQUFXLEVBQUUsQ0FBQztZQUNoQjtZQUNFLHNEQUFzRDtZQUN0RCxlQUFlLElBQUksSUFBSTtnQkFDdkIsMEVBQTBFO2dCQUMxRSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsZUFBZSxDQUFDLElBQUksZUFBZSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLE1BQU0sSUFBSSxJQUFJLENBQUMsQ0FBQyxFQUNsRixDQUFDO2dCQUNELE1BQU0sS0FBSyxHQUFHLElBQUksS0FBSyxDQUFDLHNEQUFzRCxDQUFDLENBQUM7Z0JBQ2hGLE9BQU8sVUFBVSxDQUFDLEdBQUcsRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ2pDLENBQUM7UUFDSCxDQUFDO1FBRUQsT0FBTyxJQUFJLENBQUMsd0JBQXdCLENBQUMsc0JBQXNCLEVBQUUsQ0FBQyxRQUFRLENBQUMsZUFBZSxDQUFDLENBQUM7SUFDMUYsQ0FBQztJQUVEOztPQUVHO0lBQ0gsTUFBTSxDQUFJLFFBQTBCO1FBQ2xDLE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyx1QkFBdUIsQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUMxRCxPQUFPLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxJQUFJLENBQ3JDLEdBQUcsQ0FBQyxVQUFVLENBQUMsRUFDZixVQUFVLENBQUMsQ0FBQyxLQUFZLEVBQTZDLEVBQUU7WUFDckUsbUZBQW1GO1lBQ25GLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxlQUFlLENBQUMsY0FBYyxJQUFJLEtBQUssWUFBWSxTQUFTLEVBQUUsQ0FBQztnQkFDOUUsT0FBTyxFQUFFLENBQUMsU0FBUyxDQUFDLENBQUM7WUFDdkIsQ0FBQztZQUVELHVCQUF1QjtZQUN2QixPQUFPLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUMzQixDQUFDLENBQUMsRUFDRixvQkFBb0IsRUFBRSxFQUN0QixTQUFTLENBQUMsSUFBSSxDQUFDLDBCQUEwQixDQUFDLENBQzNDLENBQUM7SUFDSixDQUFDO0lBRUQ7O09BRUc7SUFDSCxVQUFVLENBQUksUUFBMEI7UUFDdEMsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUM3QyxDQUFDO0lBRUQ7O09BRUc7SUFDSCxjQUFjLENBQUksUUFBMEI7UUFDMUMsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLHVCQUF1QixDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQzFELE9BQU8sVUFBVSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQztJQUNsRCxDQUFDO0lBRUQ7O09BRUc7SUFDSCxZQUFZLENBQUksUUFBMEI7UUFDeEMsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLHVCQUF1QixDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQzFELE9BQU8sUUFBUSxDQUFJLEdBQUcsRUFBRSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQztJQUNsRSxDQUFDO0lBRUQ7O09BRUc7SUFDSCxTQUFTLENBQUMsRUFBeUI7UUFDakMsT0FBTyxJQUFJLENBQUMsc0JBQXNCO2FBQy9CLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLDBCQUEwQixDQUFDLENBQUM7YUFDaEQsU0FBUyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQ25CLENBQUM7SUFFRDs7T0FFRztJQUNILFFBQVE7UUFDTixPQUFPLElBQUksQ0FBQyx3QkFBd0IsQ0FBQyxzQkFBc0IsRUFBRSxDQUFDLFFBQVEsRUFBRSxDQUFDO0lBQzNFLENBQUM7SUFFRDs7O09BR0c7SUFDSCxLQUFLLENBQUMsS0FBVTtRQUNkLElBQUksQ0FBQyx3QkFBd0IsQ0FBQyxzQkFBc0IsRUFBRSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUN6RSxDQUFDO0lBRU8sdUJBQXVCLENBQUMsUUFBYTtRQUMzQyxNQUFNLGNBQWMsR0FBRyxzQkFBc0IsQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUN4RCxNQUFNLGNBQWMsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLHlCQUF5QixFQUFFLENBQUM7UUFDdEUsT0FBTyxjQUFjLENBQUMsY0FBYyxDQUFDLENBQUM7SUFDeEMsQ0FBQztJQUVPLGVBQWUsQ0FBQyxpQkFBc0I7UUFDNUMsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxLQUFLLENBQUM7UUFDdEMsTUFBTSxZQUFZLEdBQUcsQ0FBQyxLQUFLLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxNQUFNLEtBQUssQ0FBQyxDQUFDO1FBRS9ELElBQUksWUFBWSxFQUFFLENBQUM7WUFDakIsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsQ0FBQztRQUM1QyxDQUFDO0lBQ0gsQ0FBQztpSUE1SFUsS0FBSyx3TEFrQk4sb0JBQW9CO3FJQWxCbkIsS0FBSyxjQURRLE1BQU07OzJGQUNuQixLQUFLO2tCQURqQixVQUFVO21CQUFDLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBRTs7MEJBa0I3QixRQUFROzswQkFDUixNQUFNOzJCQUFDLG9CQUFvQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNvbXB1dGVkLCBJbmplY3QsIEluamVjdGFibGUsIE9wdGlvbmFsLCBTaWduYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7XG4gIE9ic2VydmFibGUsXG4gIG9mLFxuICBTdWJzY3JpcHRpb24sXG4gIHRocm93RXJyb3IsXG4gIGNhdGNoRXJyb3IsXG4gIGRpc3RpbmN0VW50aWxDaGFuZ2VkLFxuICBtYXAsXG4gIHNoYXJlUmVwbGF5LFxuICB0YWtlXG59IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgybVJTklUSUFMX1NUQVRFX1RPS0VOLCDJtVN0YXRlU3RyZWFtIH0gZnJvbSAnQG5neHMvc3RvcmUvaW50ZXJuYWxzJztcblxuaW1wb3J0IHsgSW50ZXJuYWxOZ3hzRXhlY3V0aW9uU3RyYXRlZ3kgfSBmcm9tICcuL2V4ZWN1dGlvbi9pbnRlcm5hbC1uZ3hzLWV4ZWN1dGlvbi1zdHJhdGVneSc7XG5pbXBvcnQgeyBJbnRlcm5hbFN0YXRlT3BlcmF0aW9ucyB9IGZyb20gJy4vaW50ZXJuYWwvc3RhdGUtb3BlcmF0aW9ucyc7XG5pbXBvcnQgeyBnZXRSb290U2VsZWN0b3JGYWN0b3J5IH0gZnJvbSAnLi9zZWxlY3RvcnMvc2VsZWN0b3ItdXRpbHMnO1xuaW1wb3J0IHsgbGVhdmVOZ3hzIH0gZnJvbSAnLi9vcGVyYXRvcnMvbGVhdmUtbmd4cyc7XG5pbXBvcnQgeyBOZ3hzQ29uZmlnIH0gZnJvbSAnLi9zeW1ib2xzJztcbmltcG9ydCB7IFN0YXRlRmFjdG9yeSB9IGZyb20gJy4vaW50ZXJuYWwvc3RhdGUtZmFjdG9yeSc7XG5pbXBvcnQgeyBUeXBlZFNlbGVjdG9yIH0gZnJvbSAnLi9zZWxlY3RvcnMnO1xuXG5jb25zdCBOR19ERVZfTU9ERSA9IHR5cGVvZiBuZ0Rldk1vZGUgIT09ICd1bmRlZmluZWQnICYmIG5nRGV2TW9kZTtcblxuLy8gV2UgbmVlZCB0byBjaGVjayB3aGV0aGVyIHRoZSBwcm92aWRlZCBgVGAgdHlwZSBleHRlbmRzIGFuIGFycmF5IGluIG9yZGVyIHRvXG4vLyBhcHBseSB0aGUgYE5vbk51bGxhYmxlW11gIHR5cGUgdG8gaXRzIGVsZW1lbnRzLiBUaGlzIGlzIGJlY2F1c2UsIGZvclxuLy8gYGNvbnN0IGFjdGlvbnMgPSBbdW5kZWZpbmVkXWAsIHR5cGUgaW5mZXJlbmNlIHdvdWxkIHJlc3VsdCBpbiBgTm9uTnVsbGFibGU8dW5rbm93bj5gXG4vLyByYXRoZXIgdGhhbiBgTm9uTnVsbGFibGU8dW5rbm93bj5bXWAuXG50eXBlIEFjdGlvbk9yQXJyYXlPZkFjdGlvbnM8VD4gPSBUIGV4dGVuZHMgKGluZmVyIFUpW10gPyBOb25OdWxsYWJsZTxVPltdIDogTm9uTnVsbGFibGU8VD47XG5cbkBJbmplY3RhYmxlKHsgcHJvdmlkZWRJbjogJ3Jvb3QnIH0pXG5leHBvcnQgY2xhc3MgU3RvcmUge1xuICAvKipcbiAgICogVGhpcyBpcyBhIGRlcml2ZWQgc3RhdGUgc3RyZWFtIHRoYXQgbGVhdmVzIE5HWFMgZXhlY3V0aW9uIHN0cmF0ZWd5IHRvIGVtaXQgc3RhdGUgY2hhbmdlcyB3aXRoaW4gdGhlIEFuZ3VsYXIgem9uZSxcbiAgICogYmVjYXVzZSBzdGF0ZSBpcyBiZWluZyBjaGFuZ2VkIGFjdHVhbGx5IHdpdGhpbiB0aGUgYDxyb290PmAgem9uZSwgc2VlIGBJbnRlcm5hbERpc3BhdGNoZXIjZGlzcGF0Y2hTaW5nbGVgLlxuICAgKiBBbGwgc2VsZWN0cyB3b3VsZCB1c2UgdGhpcyBzdHJlYW0sIGFuZCBpdCB3b3VsZCBjYWxsIGxlYXZlIG9ubHkgb25jZSBmb3IgYW55IHN0YXRlIGNoYW5nZSBhY3Jvc3MgYWxsIGFjdGl2ZSBzZWxlY3RvcnMuXG4gICAqL1xuICBwcml2YXRlIF9zZWxlY3RhYmxlU3RhdGVTdHJlYW0gPSB0aGlzLl9zdGF0ZVN0cmVhbS5waXBlKFxuICAgIGxlYXZlTmd4cyh0aGlzLl9pbnRlcm5hbEV4ZWN1dGlvblN0cmF0ZWd5KSxcbiAgICBzaGFyZVJlcGxheSh7IGJ1ZmZlclNpemU6IDEsIHJlZkNvdW50OiB0cnVlIH0pXG4gICk7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBfc3RhdGVTdHJlYW06IMm1U3RhdGVTdHJlYW0sXG4gICAgcHJpdmF0ZSBfaW50ZXJuYWxTdGF0ZU9wZXJhdGlvbnM6IEludGVybmFsU3RhdGVPcGVyYXRpb25zLFxuICAgIHByaXZhdGUgX2NvbmZpZzogTmd4c0NvbmZpZyxcbiAgICBwcml2YXRlIF9pbnRlcm5hbEV4ZWN1dGlvblN0cmF0ZWd5OiBJbnRlcm5hbE5neHNFeGVjdXRpb25TdHJhdGVneSxcbiAgICBwcml2YXRlIF9zdGF0ZUZhY3Rvcnk6IFN0YXRlRmFjdG9yeSxcbiAgICBAT3B0aW9uYWwoKVxuICAgIEBJbmplY3QoybVJTklUSUFMX1NUQVRFX1RPS0VOKVxuICAgIGluaXRpYWxTdGF0ZVZhbHVlOiBhbnlcbiAgKSB7XG4gICAgdGhpcy5pbml0U3RhdGVTdHJlYW0oaW5pdGlhbFN0YXRlVmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIERpc3BhdGNoZXMgYWN0aW9uKHMpLlxuICAgKi9cbiAgZGlzcGF0Y2g8VD4oYWN0aW9uT3JBY3Rpb25zOiBBY3Rpb25PckFycmF5T2ZBY3Rpb25zPFQ+KTogT2JzZXJ2YWJsZTx2b2lkPiB7XG4gICAgaWYgKE5HX0RFVl9NT0RFKSB7XG4gICAgICBpZiAoXG4gICAgICAgIC8vIElmIGEgc2luZ2xlIGFjdGlvbiBpcyBkaXNwYXRjaGVkIGFuZCBpdCdzIG51bGxhYmxlLlxuICAgICAgICBhY3Rpb25PckFjdGlvbnMgPT0gbnVsbCB8fFxuICAgICAgICAvLyBJZiBhIGxpc3Qgb2YgYWN0aW9ucyBpcyBkaXNwYXRjaGVkIGFuZCBhbnkgb2YgdGhlIGFjdGlvbnMgYXJlIG51bGxhYmxlLlxuICAgICAgICAoQXJyYXkuaXNBcnJheShhY3Rpb25PckFjdGlvbnMpICYmIGFjdGlvbk9yQWN0aW9ucy5zb21lKGFjdGlvbiA9PiBhY3Rpb24gPT0gbnVsbCkpXG4gICAgICApIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ2BkaXNwYXRjaCgpYCB3YXMgY2FsbGVkIHdpdGhvdXQgcHJvdmlkaW5nIGFuIGFjdGlvbi4nKTtcbiAgICAgICAgcmV0dXJuIHRocm93RXJyb3IoKCkgPT4gZXJyb3IpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbFN0YXRlT3BlcmF0aW9ucy5nZXRSb290U3RhdGVPcGVyYXRpb25zKCkuZGlzcGF0Y2goYWN0aW9uT3JBY3Rpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZWxlY3RzIGEgc2xpY2Ugb2YgZGF0YSBmcm9tIHRoZSBzdG9yZS5cbiAgICovXG4gIHNlbGVjdDxUPihzZWxlY3RvcjogVHlwZWRTZWxlY3RvcjxUPik6IE9ic2VydmFibGU8VD4ge1xuICAgIGNvbnN0IHNlbGVjdG9yRm4gPSB0aGlzLmdldFN0b3JlQm91bmRTZWxlY3RvckZuKHNlbGVjdG9yKTtcbiAgICByZXR1cm4gdGhpcy5fc2VsZWN0YWJsZVN0YXRlU3RyZWFtLnBpcGUoXG4gICAgICBtYXAoc2VsZWN0b3JGbiksXG4gICAgICBjYXRjaEVycm9yKChlcnJvcjogRXJyb3IpOiBPYnNlcnZhYmxlPG5ldmVyPiB8IE9ic2VydmFibGU8dW5kZWZpbmVkPiA9PiB7XG4gICAgICAgIC8vIGlmIGVycm9yIGlzIFR5cGVFcnJvciB3ZSBzd2FsbG93IGl0IHRvIHByZXZlbnQgdXN1YWwgZXJyb3JzIHdpdGggcHJvcGVydHkgYWNjZXNzXG4gICAgICAgIGlmICh0aGlzLl9jb25maWcuc2VsZWN0b3JPcHRpb25zLnN1cHByZXNzRXJyb3JzICYmIGVycm9yIGluc3RhbmNlb2YgVHlwZUVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIG9mKHVuZGVmaW5lZCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXRocm93IG90aGVyIGVycm9yc1xuICAgICAgICByZXR1cm4gdGhyb3dFcnJvcihlcnJvcik7XG4gICAgICB9KSxcbiAgICAgIGRpc3RpbmN0VW50aWxDaGFuZ2VkKCksXG4gICAgICBsZWF2ZU5neHModGhpcy5faW50ZXJuYWxFeGVjdXRpb25TdHJhdGVneSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbGVjdCBvbmUgc2xpY2Ugb2YgZGF0YSBmcm9tIHRoZSBzdG9yZS5cbiAgICovXG4gIHNlbGVjdE9uY2U8VD4oc2VsZWN0b3I6IFR5cGVkU2VsZWN0b3I8VD4pOiBPYnNlcnZhYmxlPFQ+IHtcbiAgICByZXR1cm4gdGhpcy5zZWxlY3Qoc2VsZWN0b3IpLnBpcGUodGFrZSgxKSk7XG4gIH1cblxuICAvKipcbiAgICogU2VsZWN0IGEgc25hcHNob3QgZnJvbSB0aGUgc3RhdGUuXG4gICAqL1xuICBzZWxlY3RTbmFwc2hvdDxUPihzZWxlY3RvcjogVHlwZWRTZWxlY3RvcjxUPik6IFQge1xuICAgIGNvbnN0IHNlbGVjdG9yRm4gPSB0aGlzLmdldFN0b3JlQm91bmRTZWxlY3RvckZuKHNlbGVjdG9yKTtcbiAgICByZXR1cm4gc2VsZWN0b3JGbih0aGlzLl9zdGF0ZVN0cmVhbS5nZXRWYWx1ZSgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZWxlY3QgYSBzaWduYWwgZnJvbSB0aGUgc3RhdGUuXG4gICAqL1xuICBzZWxlY3RTaWduYWw8VD4oc2VsZWN0b3I6IFR5cGVkU2VsZWN0b3I8VD4pOiBTaWduYWw8VD4ge1xuICAgIGNvbnN0IHNlbGVjdG9yRm4gPSB0aGlzLmdldFN0b3JlQm91bmRTZWxlY3RvckZuKHNlbGVjdG9yKTtcbiAgICByZXR1cm4gY29tcHV0ZWQ8VD4oKCkgPT4gc2VsZWN0b3JGbih0aGlzLl9zdGF0ZVN0cmVhbS5zdGF0ZSgpKSk7XG4gIH1cblxuICAvKipcbiAgICogQWxsb3cgdGhlIHVzZXIgdG8gc3Vic2NyaWJlIHRvIHRoZSByb290IG9mIHRoZSBzdGF0ZVxuICAgKi9cbiAgc3Vic2NyaWJlKGZuPzogKHZhbHVlOiBhbnkpID0+IHZvaWQpOiBTdWJzY3JpcHRpb24ge1xuICAgIHJldHVybiB0aGlzLl9zZWxlY3RhYmxlU3RhdGVTdHJlYW1cbiAgICAgIC5waXBlKGxlYXZlTmd4cyh0aGlzLl9pbnRlcm5hbEV4ZWN1dGlvblN0cmF0ZWd5KSlcbiAgICAgIC5zdWJzY3JpYmUoZm4pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgcmF3IHZhbHVlIG9mIHRoZSBzdGF0ZS5cbiAgICovXG4gIHNuYXBzaG90KCk6IGFueSB7XG4gICAgcmV0dXJuIHRoaXMuX2ludGVybmFsU3RhdGVPcGVyYXRpb25zLmdldFJvb3RTdGF0ZU9wZXJhdGlvbnMoKS5nZXRTdGF0ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0IHRoZSBzdGF0ZSB0byBhIHNwZWNpZmljIHBvaW50IGluIHRpbWUuIFRoaXMgbWV0aG9kIGlzIHVzZWZ1bFxuICAgKiBmb3IgcGx1Z2luJ3Mgd2hvIG5lZWQgdG8gbW9kaWZ5IHRoZSBzdGF0ZSBkaXJlY3RseSBvciB1bml0IHRlc3RpbmcuXG4gICAqL1xuICByZXNldChzdGF0ZTogYW55KSB7XG4gICAgdGhpcy5faW50ZXJuYWxTdGF0ZU9wZXJhdGlvbnMuZ2V0Um9vdFN0YXRlT3BlcmF0aW9ucygpLnNldFN0YXRlKHN0YXRlKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0U3RvcmVCb3VuZFNlbGVjdG9yRm4oc2VsZWN0b3I6IGFueSkge1xuICAgIGNvbnN0IG1ha2VTZWxlY3RvckZuID0gZ2V0Um9vdFNlbGVjdG9yRmFjdG9yeShzZWxlY3Rvcik7XG4gICAgY29uc3QgcnVudGltZUNvbnRleHQgPSB0aGlzLl9zdGF0ZUZhY3RvcnkuZ2V0UnVudGltZVNlbGVjdG9yQ29udGV4dCgpO1xuICAgIHJldHVybiBtYWtlU2VsZWN0b3JGbihydW50aW1lQ29udGV4dCk7XG4gIH1cblxuICBwcml2YXRlIGluaXRTdGF0ZVN0cmVhbShpbml0aWFsU3RhdGVWYWx1ZTogYW55KTogdm9pZCB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLl9zdGF0ZVN0cmVhbS52YWx1ZTtcbiAgICBjb25zdCBzdG9yZUlzRW1wdHkgPSAhdmFsdWUgfHwgT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aCA9PT0gMDtcblxuICAgIGlmIChzdG9yZUlzRW1wdHkpIHtcbiAgICAgIHRoaXMuX3N0YXRlU3RyZWFtLm5leHQoaW5pdGlhbFN0YXRlVmFsdWUpO1xuICAgIH1cbiAgfVxufVxuIl19