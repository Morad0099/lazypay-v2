import { ɵmemoize, ɵgetStoreMetadata, ɵgetSelectorMetadata } from '@ngxs/store/internals';
const NG_DEV_MODE = typeof ngDevMode !== 'undefined' && ngDevMode;
export function createRootSelectorFactory(selectorMetaData, selectors, memoizedSelectorFn) {
    return (context) => {
        const { argumentSelectorFunctions, selectorOptions } = getRuntimeSelectorInfo(context, selectorMetaData, selectors);
        const { suppressErrors } = selectorOptions;
        return function selectFromRoot(rootState) {
            // Determine arguments from the app state using the selectors
            const results = argumentSelectorFunctions.map(argFn => argFn(rootState));
            // If the lambda attempts to access something in the state that doesn't exist,
            // it will throw a `TypeError`. Since this behavior is common, we simply return
            // `undefined` in such cases.
            try {
                return memoizedSelectorFn(...results);
            }
            catch (ex) {
                if (suppressErrors && ex instanceof TypeError) {
                    return undefined;
                }
                // We're logging an error in this function because it may be used by `select`,
                // `selectSignal`, and `selectSnapshot`. Therefore, there's no need to catch
                // exceptions there to log errors.
                if (NG_DEV_MODE) {
                    const message = 'The selector below has thrown an error upon invocation. ' +
                        'Please check for any unsafe property access that may result in null ' +
                        'or undefined values.';
                    // Avoid concatenating the message with the original function, as this will
                    // invoke `toString()` on the function. Instead, log it as the second argument.
                    // This way, developers will be able to navigate to the actual code in the browser.
                    console.error(message, selectorMetaData.originalFn);
                }
                throw ex;
            }
        };
    };
}
export function createMemoizedSelectorFn(originalFn, creationMetadata) {
    const containerClass = creationMetadata && creationMetadata.containerClass;
    const wrappedFn = function wrappedSelectorFn() {
        // eslint-disable-next-line prefer-rest-params
        const returnValue = originalFn.apply(containerClass, arguments);
        if (typeof returnValue === 'function') {
            const innerMemoizedFn = ɵmemoize.apply(null, [returnValue]);
            return innerMemoizedFn;
        }
        return returnValue;
    };
    const memoizedFn = ɵmemoize(wrappedFn);
    Object.setPrototypeOf(memoizedFn, originalFn);
    return memoizedFn;
}
function getRuntimeSelectorInfo(context, selectorMetaData, selectors = []) {
    const localSelectorOptions = selectorMetaData.getSelectorOptions();
    const selectorOptions = context.getSelectorOptions(localSelectorOptions);
    const selectorsToApply = getSelectorsToApply(selectors, selectorOptions, selectorMetaData.containerClass);
    const argumentSelectorFunctions = selectorsToApply.map(selector => {
        const factory = getRootSelectorFactory(selector);
        return factory(context);
    });
    return {
        selectorOptions,
        argumentSelectorFunctions
    };
}
function getSelectorsToApply(selectors = [], selectorOptions, containerClass) {
    const selectorsToApply = [];
    // The container state refers to the state class that includes the
    // definition of the selector function, for example:
    // @State()
    // class AnimalsState {
    //   @Selector()
    //   static getAnimals(state: AnimalsStateModel) {}
    // }
    // The `AnimalsState` serves as the container state. Additionally, the
    // selector may reside within a namespace or another class lacking the
    // `@State` decorator, thus not being treated as the container state.
    const canInjectContainerState = selectorOptions.injectContainerState || selectors.length === 0;
    if (containerClass && canInjectContainerState) {
        // If we are on a state class, add it as the first selector parameter
        const metadata = ɵgetStoreMetadata(containerClass);
        if (metadata) {
            selectorsToApply.push(containerClass);
        }
    }
    selectorsToApply.push(...selectors);
    return selectorsToApply;
}
/**
 * This function gets the factory function to create the selector to get the selected slice from the app state
 * @ignore
 */
export function getRootSelectorFactory(selector) {
    const metadata = ɵgetSelectorMetadata(selector) || ɵgetStoreMetadata(selector);
    return (metadata && metadata.makeRootSelector) || (() => selector);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VsZWN0b3ItdXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9zdG9yZS9zcmMvc2VsZWN0b3JzL3NlbGVjdG9yLXV0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDTCxRQUFRLEVBR1IsaUJBQWlCLEVBQ2pCLG9CQUFvQixFQUdyQixNQUFNLHVCQUF1QixDQUFDO0FBTS9CLE1BQU0sV0FBVyxHQUFHLE9BQU8sU0FBUyxLQUFLLFdBQVcsSUFBSSxTQUFTLENBQUM7QUFFbEUsTUFBTSxVQUFVLHlCQUF5QixDQUN2QyxnQkFBd0MsRUFDeEMsU0FBNEIsRUFDNUIsa0JBQXFCO0lBRXJCLE9BQU8sQ0FBQyxPQUFnQyxFQUFFLEVBQUU7UUFDMUMsTUFBTSxFQUFFLHlCQUF5QixFQUFFLGVBQWUsRUFBRSxHQUFHLHNCQUFzQixDQUMzRSxPQUFPLEVBQ1AsZ0JBQWdCLEVBQ2hCLFNBQVMsQ0FDVixDQUFDO1FBRUYsTUFBTSxFQUFFLGNBQWMsRUFBRSxHQUFHLGVBQWUsQ0FBQztRQUUzQyxPQUFPLFNBQVMsY0FBYyxDQUFDLFNBQWM7WUFDM0MsNkRBQTZEO1lBQzdELE1BQU0sT0FBTyxHQUFHLHlCQUF5QixDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO1lBRXpFLDhFQUE4RTtZQUM5RSwrRUFBK0U7WUFDL0UsNkJBQTZCO1lBQzdCLElBQUksQ0FBQztnQkFDSCxPQUFPLGtCQUFrQixDQUFDLEdBQUcsT0FBTyxDQUFDLENBQUM7WUFDeEMsQ0FBQztZQUFDLE9BQU8sRUFBRSxFQUFFLENBQUM7Z0JBQ1osSUFBSSxjQUFjLElBQUksRUFBRSxZQUFZLFNBQVMsRUFBRSxDQUFDO29CQUM5QyxPQUFPLFNBQVMsQ0FBQztnQkFDbkIsQ0FBQztnQkFFRCw4RUFBOEU7Z0JBQzlFLDRFQUE0RTtnQkFDNUUsa0NBQWtDO2dC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QUNwQyxPQUFPLGdCQUFnQixDQUFDO0FBQzFCLENBQUM7QUFFRDs7O0dBR0c7QUFDSCxNQUFNLFVBQVUsc0JBQXNCLENBQUMsUUFBYTtJQUNsRCxNQUFNLFFBQVEsR0FBRyxvQkFBb0IsQ0FBQyxRQUFRLENBQUMsSUFBSSxpQkFBaUIsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUMvRSxPQUFPLENBQUMsUUFBUSxJQUFJLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUMsUUFBUSxDQUFDLENBQUM7QUFDckUsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIMm1bWVtb2l6ZSxcbiAgybVSdW50aW1lU2VsZWN0b3JDb250ZXh0LFxuICDJtVNlbGVjdG9yRmFjdG9yeSxcbiAgybVnZXRTdG9yZU1ldGFkYXRhLFxuICDJtWdldFNlbGVjdG9yTWV0YWRhdGEsXG4gIMm1U2VsZWN0b3JNZXRhRGF0YU1vZGVsLFxuICDJtVNoYXJlZFNlbGVjdG9yT3B0aW9uc1xufSBmcm9tICdAbmd4cy9zdG9yZS9pbnRlcm5hbHMnO1xuXG5pbXBvcnQgeyBDcmVhdGlvbk1ldGFkYXRhLCBSdW50aW1lU2VsZWN0b3JJbmZvIH0gZnJvbSAnLi9zZWxlY3Rvci1tb2RlbHMnO1xuXG5kZWNsYXJlIGNvbnN0IG5nRGV2TW9kZTogYm9vbGVhbjtcblxuY29uc3QgTkdfREVWX01PREUgPSB0eXBlb2YgbmdEZXZNb2RlICE9PSAndW5kZWZpbmVkJyAmJiBuZ0Rldk1vZGU7XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVSb290U2VsZWN0b3JGYWN0b3J5PFQgZXh0ZW5kcyAoLi4uYXJnczogYW55W10pID0+IGFueT4oXG4gIHNlbGVjdG9yTWV0YURhdGE6IMm1U2VsZWN0b3JNZXRhRGF0YU1vZGVsLFxuICBzZWxlY3RvcnM6IGFueVtdIHwgdW5kZWZpbmVkLFxuICBtZW1vaXplZFNlbGVjdG9yRm46IFRcbik6IMm1U2VsZWN0b3JGYWN0b3J5IHtcbiAgcmV0dXJuIChjb250ZXh0OiDJtVJ1bnRpbWVTZWxlY3RvckNvbnRleHQpID0+IHtcbiAgICBjb25zdCB7IGFyZ3VtZW50U2VsZWN0b3JGdW5jdGlvbnMsIHNlbGVjdG9yT3B0aW9ucyB9ID0gZ2V0UnVudGltZVNlbGVjdG9ySW5mbyhcbiAgICAgIGNvbnRleHQsXG4gICAgICBzZWxlY3Rvck1ldGFEYXRhLFxuICAgICAgc2VsZWN0b3JzXG4gICAgKTtcblxuICAgIGNvbnN0IHsgc3VwcHJlc3NFcnJvcnMgfSA9IHNlbGVjdG9yT3B0aW9ucztcblxuICAgIHJldHVybiBmdW5jdGlvbiBzZWxlY3RGcm9tUm9vdChyb290U3RhdGU6IGFueSkge1xuICAgICAgLy8gRGV0ZXJtaW5lIGFyZ3VtZW50cyBmcm9tIHRoZSBhcHAgc3RhdGUgdXNpbmcgdGhlIHNlbGVjdG9yc1xuICAgICAgY29uc3QgcmVzdWx0cyA9IGFyZ3VtZW50U2VsZWN0b3JGdW5jdGlvbnMubWFwKGFyZ0ZuID0+IGFyZ0ZuKHJvb3RTdGF0ZSkpO1xuXG4gICAgICAvLyBJZiB0aGUgbGFtYmRhIGF0dGVtcHRzIHRvIGFjY2VzcyBzb21ldGhpbmcgaW4gdGhlIHN0YXRlIHRoYXQgZG9lc24ndCBleGlzdCxcbiAgICAgIC8vIGl0IHdpbGwgdGhyb3cgYSBgVHlwZUVycm9yYC4gU2luY2UgdGhpcyBiZWhhdmlvciBpcyBjb21tb24sIHdlIHNpbXBseSByZXR1cm5cbiAgICAgIC8vIGB1bmRlZmluZWRgIGluIHN1Y2ggY2FzZXMuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbWVtb2l6ZWRTZWxlY3RvckZuKC4uLnJlc3VsdHMpO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgaWYgKHN1cHByZXNzRXJyb3JzICYmIGV4IGluc3RhbmNlb2YgVHlwZUVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdlJ3JlIGxvZ2dpbmcgYW4gZXJyb3IgaW4gdGhpcyBmdW5jdGlvbiBiZWNhdXNlIGl0IG1heSBiZSB1c2VkIGJ5IGBzZWxlY3RgLFxuICAgICAgICAvLyBgc2VsZWN0U2lnbmFsYCwgYW5kIGBzZWxlY3RTbmFwc2hvdGAuIFRoZXJlZm9yZSwgdGhlcmUncyBubyBuZWVkIHRvIGNhdGNoXG4gICAgICAgIC8vIGV4Y2VwdGlvbnMgdGhlcmUgdG8gbG9nIGVycm9ycy5cbiAgICAgICAgaWYgKE5HX0RFVl9NT0RFKSB7XG4gICAgICAgICAgY29uc3QgbWVzc2FnZSA9XG4gICAgICAgICAgICAnVGhlIHNlbGVjdG9yIGJlbG93IGhhcyB0aHJvd24gYW4gZXJyb3IgdXBvbiBpbnZvY2F0aW9uLiAnICtcbiAgICAgICAgICAgICdQbGVhc2UgY2hlY2sgZm9yIGFueSB1bnNhZmUgcHJvcGVydHkgYWNjZXNzIHRoYXQgbWF5IHJlc3VsdCBpbiBudWxsICcgK1xuICAgICAgICAgICAgJ29yIHVuZGVmaW5lZCB2YWx1ZXMuJztcblxuICAgICAgICAgIC8vIEF2b2lkIGNvbmNhdGVuYXRpbmcgdGhlIG1lc3NhZ2Ugd2l0aCB0aGUgb3JpZ2luYWwgZnVuY3Rpb24sIGFzIHRoaXMgd2lsbFxuICAgICAgICAgIC8vIGludm9rZSBgdG9TdHJpbmcoKWAgb24gdGhlIGZ1bmN0aW9uLiBJbnN0ZWFkLCBsb2cgaXQgYXMgdGhlIHNlY29uZCBhcmd1bWVudC5cbiAgICAgICAgICAvLyBUaGlzIHdheSwgZGV2ZWxvcGVycyB3aWxsIGJlIGFibGUgdG8gbmF2aWdhdGUgdG8gdGhlIGFjdHVhbCBjb2RlIGluIHRoZSBicm93c2VyLlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSwgc2VsZWN0b3JNZXRhRGF0YS5vcmlnaW5hbEZuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IGV4O1xuICAgICAgfVxuICAgIH07XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVNZW1vaXplZFNlbGVjdG9yRm48VCBleHRlbmRzICguLi5hcmdzOiBhbnlbXSkgPT4gYW55PihcbiAgb3JpZ2luYWxGbjogVCxcbiAgY3JlYXRpb25NZXRhZGF0YTogUGFydGlhbDxDcmVhdGlvbk1ldGFkYXRhPiB8IHVuZGVmaW5lZFxuKSB7XG4gIGNvbnN0IGNvbnRhaW5lckNsYXNzID0gY3JlYXRpb25NZXRhZGF0YSAmJiBjcmVhdGlvbk1ldGFkYXRhLmNvbnRhaW5lckNsYXNzO1xuICBjb25zdCB3cmFwcGVkRm4gPSBmdW5jdGlvbiB3cmFwcGVkU2VsZWN0b3JGbigpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLXJlc3QtcGFyYW1zXG4gICAgY29uc3QgcmV0dXJuVmFsdWUgPSBvcmlnaW5hbEZuLmFwcGx5KGNvbnRhaW5lckNsYXNzLCA8YW55PmFyZ3VtZW50cyk7XG4gICAgaWYgKHR5cGVvZiByZXR1cm5WYWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29uc3QgaW5uZXJNZW1vaXplZEZuID0gybVtZW1vaXplLmFwcGx5KG51bGwsIFtyZXR1cm5WYWx1ZV0pO1xuICAgICAgcmV0dXJuIGlubmVyTWVtb2l6ZWRGbjtcbiAgICB9XG4gICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICB9IGFzIFQ7XG4gIGNvbnN0IG1lbW9pemVkRm4gPSDJtW1lbW9pemUod3JhcHBlZEZuKTtcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKG1lbW9pemVkRm4sIG9yaWdpbmFsRm4pO1xuICByZXR1cm4gbWVtb2l6ZWRGbjtcbn1cblxuZnVuY3Rpb24gZ2V0UnVudGltZVNlbGVjdG9ySW5mbyhcbiAgY29udGV4dDogybVSdW50aW1lU2VsZWN0b3JDb250ZXh0LFxuICBzZWxlY3Rvck1ldGFEYXRhOiDJtVNlbGVjdG9yTWV0YURhdGFNb2RlbCxcbiAgc2VsZWN0b3JzOiBhbnlbXSB8IHVuZGVmaW5lZCA9IFtdXG4pOiBSdW50aW1lU2VsZWN0b3JJbmZvIHtcbiAgY29uc3QgbG9jYWxTZWxlY3Rvck9wdGlvbnMgPSBzZWxlY3Rvck1ldGFEYXRhLmdldFNlbGVjdG9yT3B0aW9ucygpO1xuICBjb25zdCBzZWxlY3Rvck9wdGlvbnMgPSBjb250ZXh0LmdldFNlbGVjdG9yT3B0aW9ucyhsb2NhbFNlbGVjdG9yT3B0aW9ucyk7XG4gIGNvbnN0IHNlbGVjdG9yc1RvQXBwbHkgPSBnZXRTZWxlY3RvcnNUb0FwcGx5KFxuICAgIHNlbGVjdG9ycyxcbiAgICBzZWxlY3Rvck9wdGlvbnMsXG4gICAgc2VsZWN0b3JNZXRhRGF0YS5jb250YWluZXJDbGFzc1xuICApO1xuXG4gIGNvbnN0IGFyZ3VtZW50U2VsZWN0b3JGdW5jdGlvbnMgPSBzZWxlY3RvcnNUb0FwcGx5Lm1hcChzZWxlY3RvciA9PiB7XG4gICAgY29uc3QgZmFjdG9yeSA9IGdldFJvb3RTZWxlY3RvckZhY3Rvcnkoc2VsZWN0b3IpO1xuICAgIHJldHVybiBmYWN0b3J5KGNvbnRleHQpO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBzZWxlY3Rvck9wdGlvbnMsXG4gICAgYXJndW1lbnRTZWxlY3RvckZ1bmN0aW9uc1xuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRTZWxlY3RvcnNUb0FwcGx5KFxuICBzZWxlY3RvcnM6IGFueVtdIHwgdW5kZWZpbmVkID0gW10sXG4gIHNlbGVjdG9yT3B0aW9uczogybVTaGFyZWRTZWxlY3Rvck9wdGlvbnMsXG4gIGNvbnRhaW5lckNsYXNzOiBhbnlcbikge1xuICBjb25zdCBzZWxlY3RvcnNUb0FwcGx5ID0gW107XG4gIC8vIFRoZSBjb250YWluZXIgc3RhdGUgcmVmZXJzIHRvIHRoZSBzdGF0ZSBjbGFzcyB0aGF0IGluY2x1ZGVzIHRoZVxuICAvLyBkZWZpbml0aW9uIG9mIHRoZSBzZWxlY3RvciBmdW5jdGlvbiwgZm9yIGV4YW1wbGU6XG4gIC8vIEBTdGF0ZSgpXG4gIC8vIGNsYXNzIEFuaW1hbHNTdGF0ZSB7XG4gIC8vICAgQFNlbGVjdG9yKClcbiAgLy8gICBzdGF0aWMgZ2V0QW5pbWFscyhzdGF0ZTogQW5pbWFsc1N0YXRlTW9kZWwpIHt9XG4gIC8vIH1cbiAgLy8gVGhlIGBBbmltYWxzU3RhdGVgIHNlcnZlcyBhcyB0aGUgY29udGFpbmVyIHN0YXRlLiBBZGRpdGlvbmFsbHksIHRoZVxuICAvLyBzZWxlY3RvciBtYXkgcmVzaWRlIHdpdGhpbiBhIG5hbWVzcGFjZSBvciBhbm90aGVyIGNsYXNzIGxhY2tpbmcgdGhlXG4gIC8vIGBAU3RhdGVgIGRlY29yYXRvciwgdGh1cyBub3QgYmVpbmcgdHJlYXRlZCBhcyB0aGUgY29udGFpbmVyIHN0YXRlLlxuICBjb25zdCBjYW5JbmplY3RDb250YWluZXJTdGF0ZSA9XG4gICAgc2VsZWN0b3JPcHRpb25zLmluamVjdENvbnRhaW5lclN0YXRlIHx8IHNlbGVjdG9ycy5sZW5ndGggPT09IDA7XG5cbiAgaWYgKGNvbnRhaW5lckNsYXNzICYmIGNhbkluamVjdENvbnRhaW5lclN0YXRlKSB7XG4gICAgLy8gSWYgd2UgYXJlIG9uIGEgc3RhdGUgY2xhc3MsIGFkZCBpdCBhcyB0aGUgZmlyc3Qgc2VsZWN0b3IgcGFyYW1ldGVyXG4gICAgY29uc3QgbWV0YWRhdGEgPSDJtWdldFN0b3JlTWV0YWRhdGEoY29udGFpbmVyQ2xhc3MpO1xuICAgIGlmIChtZXRhZGF0YSkge1xuICAgICAgc2VsZWN0b3JzVG9BcHBseS5wdXNoKGNvbnRhaW5lckNsYXNzKTtcbiAgICB9XG4gIH1cbiAgc2VsZWN0b3JzVG9BcHBseS5wdXNoKC4uLnNlbGVjdG9ycyk7XG4gIHJldHVybiBzZWxlY3RvcnNUb0FwcGx5O1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gZ2V0cyB0aGUgZmFjdG9yeSBmdW5jdGlvbiB0byBjcmVhdGUgdGhlIHNlbGVjdG9yIHRvIGdldCB0aGUgc2VsZWN0ZWQgc2xpY2UgZnJvbSB0aGUgYXBwIHN0YXRlXG4gKiBAaWdub3JlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRSb290U2VsZWN0b3JGYWN0b3J5KHNlbGVjdG9yOiBhbnkpOiDJtVNlbGVjdG9yRmFjdG9yeSB7XG4gIGNvbnN0IG1ldGFkYXRhID0gybVnZXRTZWxlY3Rvck1ldGFkYXRhKHNlbGVjdG9yKSB8fCDJtWdldFN0b3JlTWV0YWRhdGEoc2VsZWN0b3IpO1xuICByZXR1cm4gKG1ldGFkYXRhICYmIG1ldGFkYXRhLm1ha2VSb290U2VsZWN0b3IpIHx8ICgoKSA9PiBzZWxlY3Rvcik7XG59XG4iXX0=