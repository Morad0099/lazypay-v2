import { Injectable, Injector, inject, ɵisPromise } from '@angular/core';
import { ɵmemoize, ɵMETA_KEY, ɵgetStoreMetadata, ɵINITIAL_STATE_TOKEN } from '@ngxs/store/internals';
import { getActionTypeFromInstance, getValue, setValue } from '@ngxs/store/plugins';
import { forkJoin, from, isObservable, of, throwError, catchError, defaultIfEmpty, filter, map, mergeMap, takeUntil, finalize } from 'rxjs';
import { NgxsConfig } from '../symbols';
import { buildGraph, findFullParentPath, nameToState, ɵPROP_GETTER, topologicalSort } from './internals';
import { NgxsActionRegistry } from '../actions/action-registry';
import { InternalActions } from '../actions-stream';
import { InternalDispatchedActionResults } from '../internal/dispatcher';
import { ensureStateNameIsUnique, ensureStatesAreDecorated } from '../utils/store-validators';
import { ensureStateClassIsInjectable } from '../ivy/ivy-enabled-in-dev-mode';
import { NgxsUnhandledActionsLogger } from '../dev-features/ngxs-unhandled-actions-logger';
import { NgxsUnhandledErrorHandler } from '../ngxs-unhandled-error-handler';
import { assignUnhandledCallback } from './unhandled-rxjs-error-callback';
import { StateContextFactory } from './state-context-factory';
import { ofActionDispatched } from '../operators/of-action';
import * as i0 from "@angular/core";
const NG_DEV_MODE = typeof ngDevMode !== 'undefined' && ngDevMode;
function cloneDefaults(defaults) {
    let value = defaults === undefined ? {} : defaults;
    if (defaults) {
        if (Array.isArray(defaults)) {
            value = defaults.slice();
        }
        else if (typeof defaults === 'object') {
            value = { ...defaults };
        }
    }
    return value;
}
/**
 * The `StateFactory` class adds root and feature states to the graph.
 * This extracts state names from state classes, checks if they already
 * exist in the global graph, throws errors if their names are invalid, etc.
 * See its constructor, state factories inject state factories that are
 * parent-level providers. This is required to get feature states from the
 * injector on the same level.
 *
 * The `NgxsModule.forFeature(...)` returns `providers: [StateFactory, ...states]`.
 * The `StateFactory` is initialized on the feature level and goes through `...states`
 * to get them from the injector through `injector.get(state)`.
 * @ignore
 */
export class StateFactory {
    constructor() {
        this._injector = inject(Injector);
        this._config = inject(NgxsConfig);
        this._parentFactory = inject(StateFactory, { optional: true, skipSelf: true });
        this._stateContextFactory = inject(StateContextFactory);
        this._actions = inject(InternalActions);
        this._actionResults = inject(InternalDispatchedActionResults);
        this._initialState = inject(ɵINITIAL_STATE_TOKEN, { optional: true });
        this._actionRegistry = inject(NgxsActionRegistry);
        this._propGetter = inject(ɵPROP_GETTER);
        this._actionsSubscription = null;
        this._ngxsUnhandledErrorHandler = null;
        this._states = [];
        this._statesByName = {};
        this._statePaths = {};
        this.getRuntimeSelectorContext = ɵmemoize(() => {
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            const stateFactory = this;
            const propGetter = stateFactory._propGetter;
            function resolveGetter(key) {
                const path = stateFactory.statePaths[key];
                return path ? propGetter(path.split('.')) : null;
            }
            const context = this._parentFactory
                ? this._parentFactory.getRuntimeSelectorContext()
                : {
                    getStateGetter(key) {
                        // Use `@__INLINE__` annotation to forcely inline `resolveGetter`.
                        // This is a Terser annotation, which will function only in the production mode.
                        let getter = /*@__INLINE__*/ resolveGetter(key);
                        if (getter) {
                            return getter;
                        }
                        return (...args) => {
                            // Late loaded getter
                            if (!getter) {
                                getter = /*@__INLINE__*/ resolveGetter(key);
                            }
                            return getter ? getter(...args) : undefined;
                        };
                    },
                    getSelectorOptions(localOptions) {
                        const globalSelectorOptions = stateFactory._config.selectorOptions;
                        return {
                            ...globalSelectorOptions,
                            ...(localOptions || {})
                        };
                    }
                };
            return context;
        });
    }
    get states() {
        return this._parentFactory ? this._parentFactory.states : this._states;
    }
    get statesByName() {
        return this._parentFactory ? this._parentFactory.statesByName : this._statesByName;
    }
    get statePaths() {
        return this._parentFactory ? this._parentFactory.statePaths : this._statePaths;
    }
    ngOnDestroy() {
        this._actionsSubscription?.unsubscribe();
    }
    /**
     * Add a new state to the global defs.
     */
    add(stateClasses) {
        if (NG_DEV_MODE) {
            ensureStatesAreDecorated(stateClasses);
        }
        const { newStates } = this.addToStatesMap(stateClasses);
        if (!newStates.length)
            return [];
        const stateGraph = buildGraph(newStates);
        const sortedStates = topologicalSort(stateGraph);
        const paths = findFullParentPath(stateGraph);
        const nameGraph = nameToState(newStates);
        const bootstrappedStores = [];
        for (const name of sortedStates) {
            const stateClass = nameGraph[name];
            const path = paths[name];
            const meta = stateClass[ɵMETA_KEY];
            this.addRuntimeInfoToMeta(meta, path);
            // Note: previously we called `ensureStateClassIsInjectable` within the
            // `State` decorator. This check is moved here because the `ɵprov` property
            // will not exist on the class in JIT mode (because it's set asynchronously
            // during JIT compilation through `Object.defineProperty`).
            if (NG_DEV_MODE) {
                ensureStateClassIsInjectable(stateClass);
            }
            const stateMap = {
                name,
                path,
                isInitialised: false,
                actions: meta.actions,
                instance: this._injector.get(stateClass),
                defaults: cloneDefaults(meta.defaults)
            };
            // ensure our store hasn't already been added
            // but don't throw since it could be lazy
            // loaded from different paths
            if (!this.hasBeenMountedAndBootstrapped(name, path)) {
                bootstrappedStores.push(stateMap);
            }
            this.states.push(stateMap);
            this.hydrateActionMetasMap(stateMap);
        }
        return bootstrappedStores;
    }
    /**
     * Add a set of states to the store and return the defaults
     */
    addAndReturnDefaults(stateClasses) {
        const classes = stateClasses || [];
        const mappedStores = this.add(classes);
        const defaults = mappedStores.reduce((result, mappedStore) => setValue(result, mappedStore.path, mappedStore.defaults), {});
        return { defaults, states: mappedStores };
    }
    connectActionHandlers() {
        // Note: We have to connect actions only once when the `StateFactory`
        //       is being created for the first time. This checks if we're in
        //       a child state factory and the parent state factory already exists.
        if (this._parentFactory || this._actionsSubscription !== null) {
            return;
        }
        this._actionsSubscription = this._actions
            .pipe(filter((ctx) => ctx.status === "DISPATCHED" /* ActionStatus.Dispatched */), mergeMap(ctx => {
            const action = ctx.action;
            return this.invokeActions(action).pipe(map(() => ({ action, status: "SUCCESSFUL" /* ActionStatus.Successful */ })), defaultIfEmpty({ action, status: "CANCELED" /* ActionStatus.Canceled */ }), catchError(error => {
                const ngxsUnhandledErrorHandler = (this._ngxsUnhandledErrorHandler ||=
                    this._injector.get(NgxsUnhandledErrorHandler));
                const handleableError = assignUnhandledCallback(error, () => ngxsUnhandledErrorHandler.handleError(error, { action }));
                return of({
                    action,
                    status: "ERRORED" /* ActionStatus.Errored */,
                    error: handleableError
                });
            }));
        }))
            .subscribe(ctx => this._actionResults.next(ctx));
    }
    /**
     * Invoke actions on the states.
     */
    invokeActions(action) {
        const type = getActionTypeFromInstance(action);
        const results = [];
        // Determines whether the dispatched action has been handled, this is assigned
        // to `true` within the below `for` loop if any `actionMetas` has been found.
        let actionHasBeenHandled = false;
        const actionHandlers = this._actionRegistry.get(type);
        if (actionHandlers) {
            for (const actionHandler of actionHandlers) {
                let result;
                try {
                    result = actionHandler(action);
                }
                catch (e) {
                    result = throwError(() => e);
                }
                results.push(result);
                actionHasBeenHandled = true;
            }
        }
        // The `NgxsUnhandledActionsLogger` is a tree-shakable class which functions
        // only during development.
        if (NG_DEV_MODE && !actionHasBeenHandled) {
            const unhandledActionsLogger = this._injector.get(NgxsUnhandledActionsLogger, null);
            // The `NgxsUnhandledActionsLogger` will not be resolved by the injector if the
            // `NgxsDevelopmentModule` is not provided. It's enough to check whether the `injector.get`
            // didn't return `null` so we may ensure the module has been imported.
            unhandledActionsLogger?.warn(action);
        }
        if (!results.length) {
            results.push(of(undefined));
        }
        return forkJoin(results);
    }
    addToStatesMap(stateClasses) {
        const newStates = [];
        const statesMap = this.statesByName;
        for (const stateClass of stateClasses) {
            const stateName = ɵgetStoreMetadata(stateClass).name;
            if (NG_DEV_MODE) {
                ensureStateNameIsUnique(stateName, stateClass, statesMap);
            }
            const unmountedState = !statesMap[stateName];
            if (unmountedState) {
                newStates.push(stateClass);
                statesMap[stateName] = stateClass;
            }
        }
        return { newStates };
    }
    addRuntimeInfoToMeta(meta, path) {
        this.statePaths[meta.name] = path;
        // TODO: versions after v3 - we plan to get rid of the `path` property because it is non-deterministic
        // we can do this when we get rid of the incorrectly exposed getStoreMetadata
        // We will need to come up with an alternative to what was exposed in v3 because this is used by many plugins
        meta.path = path;
    }
    hasBeenMountedAndBootstrapped(name, path) {
        const valueIsBootstrappedInInitialState = getValue(this._initialState, path) !== undefined;
        // This checks whether a state has been already added to the global graph and
        // its lifecycle is in 'bootstrapped' state.
        return this.statesByName[name] && valueIsBootstrappedInInitialState;
    }
    hydrateActionMetasMap({ path, actions, instance }) {
        const { dispatched$ } = this._actions;
        for (const actionType of Object.keys(actions)) {
            const actionHandlers = actions[actionType].map(actionMeta => {
                const cancelable = !!actionMeta.options.cancelUncompleted;
                return (action) => {
                    const stateContext = this._stateContextFactory.createStateContext(path);
                    let result = instance[actionMeta.fn](stateContext, action);
                    // We need to use `isPromise` instead of checking whether
                    // `result instanceof Promise`. In zone.js patched environments, `global.Promise`
                    // is the `ZoneAwarePromise`. Some APIs, which are likely not patched by zone.js
                    // for certain reasons, might not work with `instanceof`. For instance, the dynamic
                    // import returns a native promise (not a `ZoneAwarePromise`), causing this check to
                    // be falsy.
                    if (ɵisPromise(result)) {
                        result = from(result);
                    }
                    if (isObservable(result)) {
                        result = result.pipe(mergeMap((value) => {
                            if (ɵisPromise(value)) {
                                return from(value);
                            }
                            else if (isObservable(value)) {
                                return value;
                            }
                            else {
                                return of(value);
                            }
                        }), 
                        // If this observable has completed without emitting any values,
                        // we wouldn't want to complete the entire chain of actions.
                        // If any observable completes, then the action will be canceled.
                        // For instance, if any action handler had a statement like
                        // `handler(ctx) { return EMPTY; }`, then the action would be canceled.
                        // See https://github.com/ngxs/store/issues/1568
                        // Note that we actually don't care about the return type; we only care
                        // about emission, and thus `undefined` is applicable by the framework.
                        defaultIfEmpty(undefined));
                        if (cancelable) {
                            const notifier$ = dispatched$.pipe(ofActionDispatched(action));
                            result = result.pipe(takeUntil(notifier$));
                        }
                        result = result.pipe(
                        // Note that we use the `finalize` operator only when the action handler
                        // returns an observable. If the action handler is synchronous, we do not
                        // need to set the state context functions to `noop`, as the absence of a
                        // return value indicates no asynchronous functionality. If the handler's
                        // result is unsubscribed (either because the observable has completed or it
                        // was unsubscribed by `takeUntil` due to a new action being dispatched),
                        // we prevent writing to the state context.
                        finalize(() => {
                            stateContext.setState = noop;
                            stateContext.patchState = noop;
                        }));
                    }
                    else {
                        // If the action handler is synchronous and returns nothing (`void`), we
                        // still have to convert the result to a synchronous observable.
                        result = of(undefined);
                    }
                    return result;
                };
            });
            for (const actionHandler of actionHandlers) {
                this._actionRegistry.register(actionType, actionHandler);
            }
        }
    }
    /** @nocollapse */ static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.6", ngImport: i0, type: StateFactory, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    /** @nocollapse */ static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.0.6", ngImport: i0, type: StateFactory }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.6", ngImport: i0, type: StateFactory, decorators: [{
            type: Injectable
        }] });
// This is used to replace `setState` and `patchState` once the action
// handler has been unsubscribed or completed, to prevent writing
// to the state context.
function noop() { }
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RhdGUtZmFjdG9yeS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL3N0b3JlL3NyYy9pbnRlcm5hbC9zdGF0ZS1mYWN0b3J5LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsUUFBUSxFQUFhLE1BQU0sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDcEYsT0FBTyxFQUNMLFFBQVEsRUFDUixTQUFTLEVBR1QsaUJBQWlCLEVBRWpCLG9CQUFvQixFQUdyQixNQUFNLHVCQUF1QixDQUFDO0FBQy9CLE9BQU8sRUFBRSx5QkFBeUIsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFDcEYsT0FBTyxFQUNMLFFBQVEsRUFDUixJQUFJLEVBQ0osWUFBWSxFQUNaLEVBQUUsRUFFRixVQUFVLEVBQ1YsVUFBVSxFQUNWLGNBQWMsRUFDZCxNQUFNLEVBQ04sR0FBRyxFQUNILFFBQVEsRUFDUixTQUFTLEVBQ1QsUUFBUSxFQUVULE1BQU0sTUFBTSxDQUFDO0FBRWQsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLFlBQVksQ0FBQztBQUN4QyxPQUFPLEVBQ0wsVUFBVSxFQUNWLGtCQUFrQixFQUVsQixXQUFXLEVBQ1gsWUFBWSxFQUlaLGVBQWUsRUFDaEIsTUFBTSxhQUFhLENBQUM7QUFDckIsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sNEJBQTRCLENBQUM7QUFDaEUsT0FBTyxFQUErQixlQUFlLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUNqRixPQUFPLEVBQUUsK0JBQStCLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUN6RSxPQUFPLEVBQUUsdUJBQXVCLEVBQUUsd0JBQXdCLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQUM5RixPQUFPLEVBQUUsNEJBQTRCLEVBQUUsTUFBTSxnQ0FBZ0MsQ0FBQztBQUM5RSxPQUFPLEVBQUUsMEJBQTBC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QVMsQ0FBQyxDQUFDO29CQUN6QixDQUFDO29CQUVELE9BQU8sTUFBTSxDQUFDO2dCQUNoQixDQUFDLENBQUM7WUFDSixDQUFDLENBQUMsQ0FBQztZQUVILEtBQUssTUFBTSxhQUFhLElBQUksY0FBYyxFQUFFLENBQUM7Z0JBQzNDLElBQUksQ0FBQyxlQUFlLENBQUMsUUFBUSxDQUFDLFVBQVUsRUFBRSxhQUFhLENBQUMsQ0FBQztZQUMzRCxDQUFDO1FBQ0gsQ0FBQztJQUNILENBQUM7aUlBL1VVLFlBQVk7cUlBQVosWUFBWTs7MkZBQVosWUFBWTtrQkFEeEIsVUFBVTs7QUFtVlgsc0VBQXNFO0FBQ3RFLGlFQUFpRTtBQUNqRSx3QkFBd0I7QUFDeEIsU0FBUyxJQUFJLEtBQUksQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUsIEluamVjdG9yLCBPbkRlc3Ryb3ksIGluamVjdCwgybVpc1Byb21pc2UgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7XG4gIMm1bWVtb2l6ZSxcbiAgybVNRVRBX0tFWSxcbiAgybVQbGFpbk9iamVjdE9mLFxuICDJtU1ldGFEYXRhTW9kZWwsXG4gIMm1Z2V0U3RvcmVNZXRhZGF0YSxcbiAgybVTdGF0ZUNsYXNzSW50ZXJuYWwsXG4gIMm1SU5JVElBTF9TVEFURV9UT0tFTixcbiAgybVTaGFyZWRTZWxlY3Rvck9wdGlvbnMsXG4gIMm1UnVudGltZVNlbGVjdG9yQ29udGV4dFxufSBmcm9tICdAbmd4cy9zdG9yZS9pbnRlcm5hbHMnO1xuaW1wb3J0IHsgZ2V0QWN0aW9uVHlwZUZyb21JbnN0YW5jZSwgZ2V0VmFsdWUsIHNldFZhbHVlIH0gZnJvbSAnQG5neHMvc3RvcmUvcGx1Z2lucyc7XG5pbXBvcnQge1xuICBmb3JrSm9pbixcbiAgZnJvbSxcbiAgaXNPYnNlcnZhYmxlLFxuICBvZixcbiAgU3Vic2NyaXB0aW9uLFxuICB0aHJvd0Vycm9yLFxuICBjYXRjaEVycm9yLFxuICBkZWZhdWx0SWZFbXB0eSxcbiAgZmlsdGVyLFxuICBtYXAsXG4gIG1lcmdlTWFwLFxuICB0YWtlVW50aWwsXG4gIGZpbmFsaXplLFxuICBPYnNlcnZhYmxlXG59IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBOZ3hzQ29uZmlnIH0gZnJvbSAnLi4vc3ltYm9scyc7XG5pbXBvcnQge1xuICBidWlsZEdyYXBoLFxuICBmaW5kRnVsbFBhcmVudFBhdGgsXG4gIE1hcHBlZFN0b3JlLFxuICBuYW1lVG9TdGF0ZSxcbiAgybVQUk9QX0dFVFRFUixcbiAgU3RhdGVLZXlHcmFwaCxcbiAgU3RhdGVzQW5kRGVmYXVsdHMsXG4gIFN0YXRlc0J5TmFtZSxcbiAgdG9wb2xvZ2ljYWxTb3J0XG59IGZyb20gJy4vaW50ZXJuYWxzJztcbmltcG9ydCB7IE5neHNBY3Rpb25SZWdpc3RyeSB9IGZyb20gJy4uL2FjdGlvbnMvYWN0aW9uLXJlZ2lzdHJ5JztcbmltcG9ydCB7IEFjdGlvbkNvbnRleHQsIEFjdGlvblN0YXR1cywgSW50ZXJuYWxBY3Rpb25zIH0gZnJvbSAnLi4vYWN0aW9ucy1zdHJlYW0nO1xuaW1wb3J0IHsgSW50ZXJuYWxEaXNwYXRjaGVkQWN0aW9uUmVzdWx0cyB9IGZyb20gJy4uL2ludGVybmFsL2Rpc3BhdGNoZXInO1xuaW1wb3J0IHsgZW5zdXJlU3RhdGVOYW1lSXNVbmlxdWUsIGVuc3VyZVN0YXRlc0FyZURlY29yYXRlZCB9IGZyb20gJy4uL3V0aWxzL3N0b3JlLXZhbGlkYXRvcnMnO1xuaW1wb3J0IHsgZW5zdXJlU3RhdGVDbGFzc0lzSW5qZWN0YWJsZSB9IGZyb20gJy4uL2l2eS9pdnktZW5hYmxlZC1pbi1kZXYtbW9kZSc7XG5pbXBvcnQgeyBOZ3hzVW5oYW5kbGVkQWN0aW9uc0xvZ2dlciB9IGZyb20gJy4uL2Rldi1mZWF0dXJlcy9uZ3hzLXVuaGFuZGxlZC1hY3Rpb25zLWxvZ2dlcic7XG5pbXBvcnQgeyBOZ3hzVW5oYW5kbGVkRXJyb3JIYW5kbGVyIH0gZnJvbSAnLi4vbmd4cy11bmhhbmRsZWQtZXJyb3ItaGFuZGxlcic7XG5pbXBvcnQgeyBhc3NpZ25VbmhhbmRsZWRDYWxsYmFjayB9IGZyb20gJy4vdW5oYW5kbGVkLXJ4anMtZXJyb3ItY2FsbGJhY2snO1xuaW1wb3J0IHsgU3RhdGVDb250ZXh0RmFjdG9yeSB9IGZyb20gJy4vc3RhdGUtY29udGV4dC1mYWN0b3J5JztcbmltcG9ydCB7IG9mQWN0aW9uRGlzcGF0Y2hlZCB9IGZyb20gJy4uL29wZXJhdG9ycy9vZi1hY3Rpb24nO1xuXG5jb25zdCBOR19ERVZfTU9ERSA9IHR5cGVvZiBuZ0Rldk1vZGUgIT09ICd1bmRlZmluZWQnICYmIG5nRGV2TW9kZTtcblxuZnVuY3Rpb24gY2xvbmVEZWZhdWx0cyhkZWZhdWx0czogYW55KTogYW55IHtcbiAgbGV0IHZhbHVlID0gZGVmYXVsdHMgPT09IHVuZGVmaW5lZCA/IHt9IDogZGVmYXVsdHM7XG5cbiAgaWYgKGRlZmF1bHRzKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGVmYXVsdHMpKSB7XG4gICAgICB2YWx1ZSA9IGRlZmF1bHRzLnNsaWNlKCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGVmYXVsdHMgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YWx1ZSA9IHsgLi4uZGVmYXVsdHMgfTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogVGhlIGBTdGF0ZUZhY3RvcnlgIGNsYXNzIGFkZHMgcm9vdCBhbmQgZmVhdHVyZSBzdGF0ZXMgdG8gdGhlIGdyYXBoLlxuICogVGhpcyBleHRyYWN0cyBzdGF0ZSBuYW1lcyBmcm9tIHN0YXRlIGNsYXNzZXMsIGNoZWNrcyBpZiB0aGV5IGFscmVhZHlcbiAqIGV4aXN0IGluIHRoZSBnbG9iYWwgZ3JhcGgsIHRocm93cyBlcnJvcnMgaWYgdGhlaXIgbmFtZXMgYXJlIGludmFsaWQsIGV0Yy5cbiAqIFNlZSBpdHMgY29uc3RydWN0b3IsIHN0YXRlIGZhY3RvcmllcyBpbmplY3Qgc3RhdGUgZmFjdG9yaWVzIHRoYXQgYXJlXG4gKiBwYXJlbnQtbGV2ZWwgcHJvdmlkZXJzLiBUaGlzIGlzIHJlcXVpcmVkIHRvIGdldCBmZWF0dXJlIHN0YXRlcyBmcm9tIHRoZVxuICogaW5qZWN0b3Igb24gdGhlIHNhbWUgbGV2ZWwuXG4gKlxuICogVGhlIGBOZ3hzTW9kdWxlLmZvckZlYXR1cmUoLi4uKWAgcmV0dXJucyBgcHJvdmlkZXJzOiBbU3RhdGVGYWN0b3J5LCAuLi5zdGF0ZXNdYC5cbiAqIFRoZSBgU3RhdGVGYWN0b3J5YCBpcyBpbml0aWFsaXplZCBvbiB0aGUgZmVhdHVyZSBsZXZlbCBhbmQgZ29lcyB0aHJvdWdoIGAuLi5zdGF0ZXNgXG4gKiB0byBnZXQgdGhlbSBmcm9tIHRoZSBpbmplY3RvciB0aHJvdWdoIGBpbmplY3Rvci5nZXQoc3RhdGUpYC5cbiAqIEBpZ25vcmVcbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFN0YXRlRmFjdG9yeSBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG4gIHByaXZhdGUgcmVhZG9ubHkgX2luamVjdG9yID0gaW5qZWN0KEluamVjdG9yKTtcbiAgcHJpdmF0ZSByZWFkb25seSBfY29uZmlnID0gaW5qZWN0KE5neHNDb25maWcpO1xuICBwcml2YXRlIHJlYWRvbmx5IF9wYXJlbnRGYWN0b3J5ID0gaW5qZWN0KFN0YXRlRmFjdG9yeSwgeyBvcHRpb25hbDogdHJ1ZSwgc2tpcFNlbGY6IHRydWUgfSk7XG4gIHByaXZhdGUgcmVhZG9ubHkgX3N0YXRlQ29udGV4dEZhY3RvcnkgPSBpbmplY3QoU3RhdGVDb250ZXh0RmFjdG9yeSk7XG4gIHByaXZhdGUgcmVhZG9ubHkgX2FjdGlvbnMgPSBpbmplY3QoSW50ZXJuYWxBY3Rpb25zKTtcbiAgcHJpdmF0ZSByZWFkb25seSBfYWN0aW9uUmVzdWx0cyA9IGluamVjdChJbnRlcm5hbERpc3BhdGNoZWRBY3Rpb25SZXN1bHRzKTtcbiAgcHJpdmF0ZSByZWFkb25seSBfaW5pdGlhbFN0YXRlID0gaW5qZWN0KMm1SU5JVElBTF9TVEFURV9UT0tFTiwgeyBvcHRpb25hbDogdHJ1ZSB9KTtcbiAgcHJpdmF0ZSByZWFkb25seSBfYWN0aW9uUmVnaXN0cnkgPSBpbmplY3QoTmd4c0FjdGlvblJlZ2lzdHJ5KTtcbiAgcHJpdmF0ZSByZWFkb25seSBfcHJvcEdldHRlciA9IGluamVjdCjJtVBST1BfR0VUVEVSKTtcblxuICBwcml2YXRlIF9hY3Rpb25zU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb24gfCBudWxsID0gbnVsbDtcblxuICBwcml2YXRlIF9uZ3hzVW5oYW5kbGVkRXJyb3JIYW5kbGVyOiBOZ3hzVW5oYW5kbGVkRXJyb3JIYW5kbGVyID0gbnVsbCE7XG5cbiAgcHJpdmF0ZSBfc3RhdGVzOiBNYXBwZWRTdG9yZVtdID0gW107XG4gIGdldCBzdGF0ZXMoKTogTWFwcGVkU3RvcmVbXSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhcmVudEZhY3RvcnkgPyB0aGlzLl9wYXJlbnRGYWN0b3J5LnN0YXRlcyA6IHRoaXMuX3N0YXRlcztcbiAgfVxuXG4gIHByaXZhdGUgX3N0YXRlc0J5TmFtZTogU3RhdGVzQnlOYW1lID0ge307XG4gIGdldCBzdGF0ZXNCeU5hbWUoKTogU3RhdGVzQnlOYW1lIHtcbiAgICByZXR1cm4gdGhpcy5fcGFyZW50RmFjdG9yeSA/IHRoaXMuX3BhcmVudEZhY3Rvcnkuc3RhdGVzQnlOYW1lIDogdGhpcy5fc3RhdGVzQnlOYW1lO1xuICB9XG5cbiAgcHJpdmF0ZSBfc3RhdGVQYXRoczogybVQbGFpbk9iamVjdE9mPHN0cmluZz4gPSB7fTtcbiAgcHJpdmF0ZSBnZXQgc3RhdGVQYXRocygpOiDJtVBsYWluT2JqZWN0T2Y8c3RyaW5nPiB7XG4gICAgcmV0dXJuIHRoaXMuX3BhcmVudEZhY3RvcnkgPyB0aGlzLl9wYXJlbnRGYWN0b3J5LnN0YXRlUGF0aHMgOiB0aGlzLl9zdGF0ZVBhdGhzO1xuICB9XG5cbiAgZ2V0UnVudGltZVNlbGVjdG9yQ29udGV4dCA9IMm1bWVtb2l6ZSgoKSA9PiB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby10aGlzLWFsaWFzXG4gICAgY29uc3Qgc3RhdGVGYWN0b3J5ID0gdGhpcztcbiAgICBjb25zdCBwcm9wR2V0dGVyID0gc3RhdGVGYWN0b3J5Ll9wcm9wR2V0dGVyO1xuXG4gICAgZnVuY3Rpb24gcmVzb2x2ZUdldHRlcihrZXk6IHN0cmluZykge1xuICAgICAgY29uc3QgcGF0aCA9IHN0YXRlRmFjdG9yeS5zdGF0ZVBhdGhzW2tleV07XG4gICAgICByZXR1cm4gcGF0aCA/IHByb3BHZXR0ZXIocGF0aC5zcGxpdCgnLicpKSA6IG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgY29udGV4dDogybVSdW50aW1lU2VsZWN0b3JDb250ZXh0ID0gdGhpcy5fcGFyZW50RmFjdG9yeVxuICAgICAgPyB0aGlzLl9wYXJlbnRGYWN0b3J5LmdldFJ1bnRpbWVTZWxlY3RvckNvbnRleHQoKVxuICAgICAgOiB7XG4gICAgICAgICAgZ2V0U3RhdGVHZXR0ZXIoa2V5OiBzdHJpbmcpIHtcbiAgICAgICAgICAgIC8vIFVzZSBgQF9fSU5MSU5FX19gIGFubm90YXRpb24gdG8gZm9yY2VseSBpbmxpbmUgYHJlc29sdmVHZXR0ZXJgLlxuICAgICAgICAgICAgLy8gVGhpcyBpcyBhIFRlcnNlciBhbm5vdGF0aW9uLCB3aGljaCB3aWxsIGZ1bmN0aW9uIG9ubHkgaW4gdGhlIHByb2R1Y3Rpb24gbW9kZS5cbiAgICAgICAgICAgIGxldCBnZXR0ZXIgPSAvKkBfX0lOTElORV9fKi8gcmVzb2x2ZUdldHRlcihrZXkpO1xuICAgICAgICAgICAgaWYgKGdldHRlcikge1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICAgIC8vIExhdGUgbG9hZGVkIGdldHRlclxuICAgICAgICAgICAgICBpZiAoIWdldHRlcikge1xuICAgICAgICAgICAgICAgIGdldHRlciA9IC8qQF9fSU5MSU5FX18qLyByZXNvbHZlR2V0dGVyKGtleSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGdldHRlciA/IGdldHRlciguLi5hcmdzKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXRTZWxlY3Rvck9wdGlvbnMobG9jYWxPcHRpb25zPzogybVTaGFyZWRTZWxlY3Rvck9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGdsb2JhbFNlbGVjdG9yT3B0aW9ucyA9IHN0YXRlRmFjdG9yeS5fY29uZmlnLnNlbGVjdG9yT3B0aW9ucztcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIC4uLmdsb2JhbFNlbGVjdG9yT3B0aW9ucyxcbiAgICAgICAgICAgICAgLi4uKGxvY2FsT3B0aW9ucyB8fCB7fSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIHJldHVybiBjb250ZXh0O1xuICB9KTtcblxuICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICB0aGlzLl9hY3Rpb25zU3Vic2NyaXB0aW9uPy51bnN1YnNjcmliZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIG5ldyBzdGF0ZSB0byB0aGUgZ2xvYmFsIGRlZnMuXG4gICAqL1xuICBhZGQoc3RhdGVDbGFzc2VzOiDJtVN0YXRlQ2xhc3NJbnRlcm5hbFtdKTogTWFwcGVkU3RvcmVbXSB7XG4gICAgaWYgKE5HX0RFVl9NT0RFKSB7XG4gICAgICBlbnN1cmVTdGF0ZXNBcmVEZWNvcmF0ZWQoc3RhdGVDbGFzc2VzKTtcbiAgICB9XG5cbiAgICBjb25zdCB7IG5ld1N0YXRlcyB9ID0gdGhpcy5hZGRUb1N0YXRlc01hcChzdGF0ZUNsYXNzZXMpO1xuICAgIGlmICghbmV3U3RhdGVzLmxlbmd0aCkgcmV0dXJuIFtdO1xuXG4gICAgY29uc3Qgc3RhdGVHcmFwaDogU3RhdGVLZXlHcmFwaCA9IGJ1aWxkR3JhcGgobmV3U3RhdGVzKTtcbiAgICBjb25zdCBzb3J0ZWRTdGF0ZXM6IHN0cmluZ1tdID0gdG9wb2xvZ2ljYWxTb3J0KHN0YXRlR3JhcGgpO1xuICAgIGNvbnN0IHBhdGhzOiDJtVBsYWluT2JqZWN0T2Y8c3RyaW5nPiA9IGZpbmRGdWxsUGFyZW50UGF0aChzdGF0ZUdyYXBoKTtcbiAgICBjb25zdCBuYW1lR3JhcGg6IMm1UGxhaW5PYmplY3RPZjzJtVN0YXRlQ2xhc3NJbnRlcm5hbD4gPSBuYW1lVG9TdGF0ZShuZXdTdGF0ZXMpO1xuICAgIGNvbnN0IGJvb3RzdHJhcHBlZFN0b3JlczogTWFwcGVkU3RvcmVbXSA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBuYW1lIG9mIHNvcnRlZFN0YXRlcykge1xuICAgICAgY29uc3Qgc3RhdGVDbGFzczogybVTdGF0ZUNsYXNzSW50ZXJuYWwgPSBuYW1lR3JhcGhbbmFtZV07XG4gICAgICBjb25zdCBwYXRoOiBzdHJpbmcgPSBwYXRoc1tuYW1lXTtcbiAgICAgIGNvbnN0IG1ldGE6IMm1TWV0YURhdGFNb2RlbCA9IHN0YXRlQ2xhc3NbybVNRVRBX0tFWV0hO1xuXG4gICAgICB0aGlzLmFkZFJ1bnRpbWVJbmZvVG9NZXRhKG1ldGEsIHBhdGgpO1xuXG4gICAgICAvLyBOb3RlOiBwcmV2aW91c2x5IHdlIGNhbGxlZCBgZW5zdXJlU3RhdGVDbGFzc0lzSW5qZWN0YWJsZWAgd2l0aGluIHRoZVxuICAgICAgLy8gYFN0YXRlYCBkZWNvcmF0b3IuIFRoaXMgY2hlY2sgaXMgbW92ZWQgaGVyZSBiZWNhdXNlIHRoZSBgybVwcm92YCBwcm9wZXJ0eVxuICAgICAgLy8gd2lsbCBub3QgZXhpc3Qgb24gdGhlIGNsYXNzIGluIEpJVCBtb2RlIChiZWNhdXNlIGl0J3Mgc2V0IGFzeW5jaHJvbm91c2x5XG4gICAgICAvLyBkdXJpbmcgSklUIGNvbXBpbGF0aW9uIHRocm91Z2ggYE9iamVjdC5kZWZpbmVQcm9wZXJ0eWApLlxuICAgICAgaWYgKE5HX0RFVl9NT0RFKSB7XG4gICAgICAgIGVuc3VyZVN0YXRlQ2xhc3NJc0luamVjdGFibGUoc3RhdGVDbGFzcyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHN0YXRlTWFwOiBNYXBwZWRTdG9yZSA9IHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgcGF0aCxcbiAgICAgICAgaXNJbml0aWFsaXNlZDogZmFsc2UsXG4gICAgICAgIGFjdGlvbnM6IG1ldGEuYWN0aW9ucyxcbiAgICAgICAgaW5zdGFuY2U6IHRoaXMuX2luamVjdG9yLmdldChzdGF0ZUNsYXNzKSxcbiAgICAgICAgZGVmYXVsdHM6IGNsb25lRGVmYXVsdHMobWV0YS5kZWZhdWx0cylcbiAgICAgIH07XG5cbiAgICAgIC8vIGVuc3VyZSBvdXIgc3RvcmUgaGFzbid0IGFscmVhZHkgYmVlbiBhZGRlZFxuICAgICAgLy8gYnV0IGRvbid0IHRocm93IHNpbmNlIGl0IGNvdWxkIGJlIGxhenlcbiAgICAgIC8vIGxvYWRlZCBmcm9tIGRpZmZlcmVudCBwYXRoc1xuICAgICAgaWYgKCF0aGlzLmhhc0JlZW5Nb3VudGVkQW5kQm9vdHN0cmFwcGVkKG5hbWUsIHBhdGgpKSB7XG4gICAgICAgIGJvb3RzdHJhcHBlZFN0b3Jlcy5wdXNoKHN0YXRlTWFwKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zdGF0ZXMucHVzaChzdGF0ZU1hcCk7XG4gICAgICB0aGlzLmh5ZHJhdGVBY3Rpb25NZXRhc01hcChzdGF0ZU1hcCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJvb3RzdHJhcHBlZFN0b3JlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBzZXQgb2Ygc3RhdGVzIHRvIHRoZSBzdG9yZSBhbmQgcmV0dXJuIHRoZSBkZWZhdWx0c1xuICAgKi9cbiAgYWRkQW5kUmV0dXJuRGVmYXVsdHMoc3RhdGVDbGFzc2VzOiDJtVN0YXRlQ2xhc3NJbnRlcm5hbFtdKTogU3RhdGVzQW5kRGVmYXVsdHMge1xuICAgIGNvbnN0IGNsYXNzZXM6IMm1U3RhdGVDbGFzc0ludGVybmFsW10gPSBzdGF0ZUNsYXNzZXMgfHwgW107XG5cbiAgICBjb25zdCBtYXBwZWRTdG9yZXM6IE1hcHBlZFN0b3JlW10gPSB0aGlzLmFkZChjbGFzc2VzKTtcbiAgICBjb25zdCBkZWZhdWx0cyA9IG1hcHBlZFN0b3Jlcy5yZWR1Y2UoXG4gICAgICAocmVzdWx0OiBhbnksIG1hcHBlZFN0b3JlOiBNYXBwZWRTdG9yZSkgPT5cbiAgICAgICAgc2V0VmFsdWUocmVzdWx0LCBtYXBwZWRTdG9yZS5wYXRoLCBtYXBwZWRTdG9yZS5kZWZhdWx0cyksXG4gICAgICB7fVxuICAgICk7XG4gICAgcmV0dXJuIHsgZGVmYXVsdHMsIHN0YXRlczogbWFwcGVkU3RvcmVzIH07XG4gIH1cblxuICBjb25uZWN0QWN0aW9uSGFuZGxlcnMoKTogdm9pZCB7XG4gICAgLy8gTm90ZTogV2UgaGF2ZSB0byBjb25uZWN0IGFjdGlvbnMgb25seSBvbmNlIHdoZW4gdGhlIGBTdGF0ZUZhY3RvcnlgXG4gICAgLy8gICAgICAgaXMgYmVpbmcgY3JlYXRlZCBmb3IgdGhlIGZpcnN0IHRpbWUuIFRoaXMgY2hlY2tzIGlmIHdlJ3JlIGluXG4gICAgLy8gICAgICAgYSBjaGlsZCBzdGF0ZSBmYWN0b3J5IGFuZCB0aGUgcGFyZW50IHN0YXRlIGZhY3RvcnkgYWxyZWFkeSBleGlzdHMuXG4gICAgaWYgKHRoaXMuX3BhcmVudEZhY3RvcnkgfHwgdGhpcy5fYWN0aW9uc1N1YnNjcmlwdGlvbiAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX2FjdGlvbnNTdWJzY3JpcHRpb24gPSB0aGlzLl9hY3Rpb25zXG4gICAgICAucGlwZShcbiAgICAgICAgZmlsdGVyKChjdHg6IEFjdGlvbkNvbnRleHQpID0+IGN0eC5zdGF0dXMgPT09IEFjdGlvblN0YXR1cy5EaXNwYXRjaGVkKSxcbiAgICAgICAgbWVyZ2VNYXAoY3R4ID0+IHtcbiAgICAgICAgICBjb25zdCBhY3Rpb246IGFueSA9IGN0eC5hY3Rpb247XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaW52b2tlQWN0aW9ucyhhY3Rpb24pLnBpcGUoXG4gICAgICAgICAgICBtYXAoKCkgPT4gPEFjdGlvbkNvbnRleHQ+eyBhY3Rpb24sIHN0YXR1czogQWN0aW9uU3RhdHVzLlN1Y2Nlc3NmdWwgfSksXG4gICAgICAgICAgICBkZWZhdWx0SWZFbXB0eSg8QWN0aW9uQ29udGV4dD57IGFjdGlvbiwgc3RhdHVzOiBBY3Rpb25TdGF0dXMuQ2FuY2VsZWQgfSksXG4gICAgICAgICAgICBjYXRjaEVycm9yKGVycm9yID0+IHtcbiAgICAgICAgICAgICAgY29uc3Qgbmd4c1VuaGFuZGxlZEVycm9ySGFuZGxlciA9ICh0aGlzLl9uZ3hzVW5oYW5kbGVkRXJyb3JIYW5kbGVyIHx8PVxuICAgICAgICAgICAgICAgIHRoaXMuX2luamVjdG9yLmdldChOZ3hzVW5oYW5kbGVkRXJyb3JIYW5kbGVyKSk7XG4gICAgICAgICAgICAgIGNvbnN0IGhhbmRsZWFibGVFcnJvciA9IGFzc2lnblVuaGFuZGxlZENhbGxiYWNrKGVycm9yLCAoKSA9PlxuICAgICAgICAgICAgICAgIG5neHNVbmhhbmRsZWRFcnJvckhhbmRsZXIuaGFuZGxlRXJyb3IoZXJyb3IsIHsgYWN0aW9uIH0pXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHJldHVybiBvZig8QWN0aW9uQ29udGV4dD57XG4gICAgICAgICAgICAgICAgYWN0aW9uLFxuICAgICAgICAgICAgICAgIHN0YXR1czogQWN0aW9uU3RhdHVzLkVycm9yZWQsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGhhbmRsZWFibGVFcnJvclxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfSlcbiAgICAgIClcbiAgICAgIC5zdWJzY3JpYmUoY3R4ID0+IHRoaXMuX2FjdGlvblJlc3VsdHMubmV4dChjdHgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2UgYWN0aW9ucyBvbiB0aGUgc3RhdGVzLlxuICAgKi9cbiAgcHJpdmF0ZSBpbnZva2VBY3Rpb25zKGFjdGlvbjogYW55KTogT2JzZXJ2YWJsZTx1bmtub3duW10+IHtcbiAgICBjb25zdCB0eXBlID0gZ2V0QWN0aW9uVHlwZUZyb21JbnN0YW5jZShhY3Rpb24pITtcbiAgICBjb25zdCByZXN1bHRzOiBPYnNlcnZhYmxlPHVua25vd24+W10gPSBbXTtcblxuICAgIC8vIERldGVybWluZXMgd2hldGhlciB0aGUgZGlzcGF0Y2hlZCBhY3Rpb24gaGFzIGJlZW4gaGFuZGxlZCwgdGhpcyBpcyBhc3NpZ25lZFxuICAgIC8vIHRvIGB0cnVlYCB3aXRoaW4gdGhlIGJlbG93IGBmb3JgIGxvb3AgaWYgYW55IGBhY3Rpb25NZXRhc2AgaGFzIGJlZW4gZm91bmQuXG4gICAgbGV0IGFjdGlvbkhhc0JlZW5IYW5kbGVkID0gZmFsc2U7XG5cbiAgICBjb25zdCBhY3Rpb25IYW5kbGVycyA9IHRoaXMuX2FjdGlvblJlZ2lzdHJ5LmdldCh0eXBlKTtcblxuICAgIGlmIChhY3Rpb25IYW5kbGVycykge1xuICAgICAgZm9yIChjb25zdCBhY3Rpb25IYW5kbGVyIG9mIGFjdGlvbkhhbmRsZXJzKSB7XG4gICAgICAgIGxldCByZXN1bHQ7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXN1bHQgPSBhY3Rpb25IYW5kbGVyKGFjdGlvbik7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXN1bHQgPSB0aHJvd0Vycm9yKCgpID0+IGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdCk7XG5cbiAgICAgICAgYWN0aW9uSGFzQmVlbkhhbmRsZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoZSBgTmd4c1VuaGFuZGxlZEFjdGlvbnNMb2dnZXJgIGlzIGEgdHJlZS1zaGFrYWJsZSBjbGFzcyB3aGljaCBmdW5jdGlvbnNcbiAgICAvLyBvbmx5IGR1cmluZyBkZXZlbG9wbWVudC5cbiAgICBpZiAoTkdfREVWX01PREUgJiYgIWFjdGlvbkhhc0JlZW5IYW5kbGVkKSB7XG4gICAgICBjb25zdCB1bmhhbmRsZWRBY3Rpb25zTG9nZ2VyID0gdGhpcy5faW5qZWN0b3IuZ2V0KE5neHNVbmhhbmRsZWRBY3Rpb25zTG9nZ2VyLCBudWxsKTtcbiAgICAgIC8vIFRoZSBgTmd4c1VuaGFuZGxlZEFjdGlvbnNMb2dnZXJgIHdpbGwgbm90IGJlIHJlc29sdmVkIGJ5IHRoZSBpbmplY3RvciBpZiB0aGVcbiAgICAgIC8vIGBOZ3hzRGV2ZWxvcG1lbnRNb2R1bGVgIGlzIG5vdCBwcm92aWRlZC4gSXQncyBlbm91Z2ggdG8gY2hlY2sgd2hldGhlciB0aGUgYGluamVjdG9yLmdldGBcbiAgICAgIC8vIGRpZG4ndCByZXR1cm4gYG51bGxgIHNvIHdlIG1heSBlbnN1cmUgdGhlIG1vZHVsZSBoYXMgYmVlbiBpbXBvcnRlZC5cbiAgICAgIHVuaGFuZGxlZEFjdGlvbnNMb2dnZXI/Lndhcm4oYWN0aW9uKTtcbiAgICB9XG5cbiAgICBpZiAoIXJlc3VsdHMubGVuZ3RoKSB7XG4gICAgICByZXN1bHRzLnB1c2gob2YodW5kZWZpbmVkKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZvcmtKb2luKHJlc3VsdHMpO1xuICB9XG5cbiAgcHJpdmF0ZSBhZGRUb1N0YXRlc01hcChzdGF0ZUNsYXNzZXM6IMm1U3RhdGVDbGFzc0ludGVybmFsW10pOiB7XG4gICAgbmV3U3RhdGVzOiDJtVN0YXRlQ2xhc3NJbnRlcm5hbFtdO1xuICB9IHtcbiAgICBjb25zdCBuZXdTdGF0ZXM6IMm1U3RhdGVDbGFzc0ludGVybmFsW10gPSBbXTtcbiAgICBjb25zdCBzdGF0ZXNNYXA6IFN0YXRlc0J5TmFtZSA9IHRoaXMuc3RhdGVzQnlOYW1lO1xuXG4gICAgZm9yIChjb25zdCBzdGF0ZUNsYXNzIG9mIHN0YXRlQ2xhc3Nlcykge1xuICAgICAgY29uc3Qgc3RhdGVOYW1lID0gybVnZXRTdG9yZU1ldGFkYXRhKHN0YXRlQ2xhc3MpLm5hbWUhO1xuICAgICAgaWYgKE5HX0RFVl9NT0RFKSB7XG4gICAgICAgIGVuc3VyZVN0YXRlTmFtZUlzVW5pcXVlKHN0YXRlTmFtZSwgc3RhdGVDbGFzcywgc3RhdGVzTWFwKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHVubW91bnRlZFN0YXRlID0gIXN0YXRlc01hcFtzdGF0ZU5hbWVdO1xuICAgICAgaWYgKHVubW91bnRlZFN0YXRlKSB7XG4gICAgICAgIG5ld1N0YXRlcy5wdXNoKHN0YXRlQ2xhc3MpO1xuICAgICAgICBzdGF0ZXNNYXBbc3RhdGVOYW1lXSA9IHN0YXRlQ2xhc3M7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgbmV3U3RhdGVzIH07XG4gIH1cblxuICBwcml2YXRlIGFkZFJ1bnRpbWVJbmZvVG9NZXRhKG1ldGE6IMm1TWV0YURhdGFNb2RlbCwgcGF0aDogc3RyaW5nKTogdm9pZCB7XG4gICAgdGhpcy5zdGF0ZVBhdGhzW21ldGEubmFtZSFdID0gcGF0aDtcbiAgICAvLyBUT0RPOiB2ZXJzaW9ucyBhZnRlciB2MyAtIHdlIHBsYW4gdG8gZ2V0IHJpZCBvZiB0aGUgYHBhdGhgIHByb3BlcnR5IGJlY2F1c2UgaXQgaXMgbm9uLWRldGVybWluaXN0aWNcbiAgICAvLyB3ZSBjYW4gZG8gdGhpcyB3aGVuIHdlIGdldCByaWQgb2YgdGhlIGluY29ycmVjdGx5IGV4cG9zZWQgZ2V0U3RvcmVNZXRhZGF0YVxuICAgIC8vIFdlIHdpbGwgbmVlZCB0byBjb21lIHVwIHdpdGggYW4gYWx0ZXJuYXRpdmUgdG8gd2hhdCB3YXMgZXhwb3NlZCBpbiB2MyBiZWNhdXNlIHRoaXMgaXMgdXNlZCBieSBtYW55IHBsdWdpbnNcbiAgICBtZXRhLnBhdGggPSBwYXRoO1xuICB9XG5cbiAgcHJpdmF0ZSBoYXNCZWVuTW91bnRlZEFuZEJvb3RzdHJhcHBlZChuYW1lOiBzdHJpbmcsIHBhdGg6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IHZhbHVlSXNCb290c3RyYXBwZWRJbkluaXRpYWxTdGF0ZTogYm9vbGVhbiA9XG4gICAgICBnZXRWYWx1ZSh0aGlzLl9pbml0aWFsU3RhdGUsIHBhdGgpICE9PSB1bmRlZmluZWQ7XG4gICAgLy8gVGhpcyBjaGVja3Mgd2hldGhlciBhIHN0YXRlIGhhcyBiZWVuIGFscmVhZHkgYWRkZWQgdG8gdGhlIGdsb2JhbCBncmFwaCBhbmRcbiAgICAvLyBpdHMgbGlmZWN5Y2xlIGlzIGluICdib290c3RyYXBwZWQnIHN0YXRlLlxuICAgIHJldHVybiB0aGlzLnN0YXRlc0J5TmFtZVtuYW1lXSAmJiB2YWx1ZUlzQm9vdHN0cmFwcGVkSW5Jbml0aWFsU3RhdGU7XG4gIH1cblxuICBwcml2YXRlIGh5ZHJhdGVBY3Rpb25NZXRhc01hcCh7IHBhdGgsIGFjdGlvbnMsIGluc3RhbmNlIH06IE1hcHBlZFN0b3JlKTogdm9pZCB7XG4gICAgY29uc3QgeyBkaXNwYXRjaGVkJCB9ID0gdGhpcy5fYWN0aW9ucztcbiAgICBmb3IgKGNvbnN0IGFjdGlvblR5cGUgb2YgT2JqZWN0LmtleXMoYWN0aW9ucykpIHtcbiAgICAgIGNvbnN0IGFjdGlvbkhhbmRsZXJzID0gYWN0aW9uc1thY3Rpb25UeXBlXS5tYXAoYWN0aW9uTWV0YSA9PiB7XG4gICAgICAgIGNvbnN0IGNhbmNlbGFibGUgPSAhIWFjdGlvbk1ldGEub3B0aW9ucy5jYW5jZWxVbmNvbXBsZXRlZDtcblxuICAgICAgICByZXR1cm4gKGFjdGlvbjogYW55KSA9PiB7XG4gICAgICAgICAgY29uc3Qgc3RhdGVDb250ZXh0ID0gdGhpcy5fc3RhdGVDb250ZXh0RmFjdG9yeS5jcmVhdGVTdGF0ZUNvbnRleHQocGF0aCk7XG5cbiAgICAgICAgICBsZXQgcmVzdWx0ID0gaW5zdGFuY2VbYWN0aW9uTWV0YS5mbl0oc3RhdGVDb250ZXh0LCBhY3Rpb24pO1xuXG4gICAgICAgICAgLy8gV2UgbmVlZCB0byB1c2UgYGlzUHJvbWlzZWAgaW5zdGVhZCBvZiBjaGVja2luZyB3aGV0aGVyXG4gICAgICAgICAgLy8gYHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2VgLiBJbiB6b25lLmpzIHBhdGNoZWQgZW52aXJvbm1lbnRzLCBgZ2xvYmFsLlByb21pc2VgXG4gICAgICAgICAgLy8gaXMgdGhlIGBab25lQXdhcmVQcm9taXNlYC4gU29tZSBBUElzLCB3aGljaCBhcmUgbGlrZWx5IG5vdCBwYXRjaGVkIGJ5IHpvbmUuanNcbiAgICAgICAgICAvLyBmb3IgY2VydGFpbiByZWFzb25zLCBtaWdodCBub3Qgd29yayB3aXRoIGBpbnN0YW5jZW9mYC4gRm9yIGluc3RhbmNlLCB0aGUgZHluYW1pY1xuICAgICAgICAgIC8vIGltcG9ydCByZXR1cm5zIGEgbmF0aXZlIHByb21pc2UgKG5vdCBhIGBab25lQXdhcmVQcm9taXNlYCksIGNhdXNpbmcgdGhpcyBjaGVjayB0b1xuICAgICAgICAgIC8vIGJlIGZhbHN5LlxuICAgICAgICAgIGlmICjJtWlzUHJvbWlzZShyZXN1bHQpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBmcm9tKHJlc3VsdCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGlzT2JzZXJ2YWJsZShyZXN1bHQpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQucGlwZShcbiAgICAgICAgICAgICAgbWVyZ2VNYXAoKHZhbHVlOiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoybVpc1Byb21pc2UodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZnJvbSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc09ic2VydmFibGUodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBvZih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgLy8gSWYgdGhpcyBvYnNlcnZhYmxlIGhhcyBjb21wbGV0ZWQgd2l0aG91dCBlbWl0dGluZyBhbnkgdmFsdWVzLFxuICAgICAgICAgICAgICAvLyB3ZSB3b3VsZG4ndCB3YW50IHRvIGNvbXBsZXRlIHRoZSBlbnRpcmUgY2hhaW4gb2YgYWN0aW9ucy5cbiAgICAgICAgICAgICAgLy8gSWYgYW55IG9ic2VydmFibGUgY29tcGxldGVzLCB0aGVuIHRoZSBhY3Rpb24gd2lsbCBiZSBjYW5jZWxlZC5cbiAgICAgICAgICAgICAgLy8gRm9yIGluc3RhbmNlLCBpZiBhbnkgYWN0aW9uIGhhbmRsZXIgaGFkIGEgc3RhdGVtZW50IGxpa2VcbiAgICAgICAgICAgICAgLy8gYGhhbmRsZXIoY3R4KSB7IHJldHVybiBFTVBUWTsgfWAsIHRoZW4gdGhlIGFjdGlvbiB3b3VsZCBiZSBjYW5jZWxlZC5cbiAgICAgICAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9uZ3hzL3N0b3JlL2lzc3Vlcy8xNTY4XG4gICAgICAgICAgICAgIC8vIE5vdGUgdGhhdCB3ZSBhY3R1YWxseSBkb24ndCBjYXJlIGFib3V0IHRoZSByZXR1cm4gdHlwZTsgd2Ugb25seSBjYXJlXG4gICAgICAgICAgICAgIC8vIGFib3V0IGVtaXNzaW9uLCBhbmQgdGh1cyBgdW5kZWZpbmVkYCBpcyBhcHBsaWNhYmxlIGJ5IHRoZSBmcmFtZXdvcmsuXG4gICAgICAgICAgICAgIGRlZmF1bHRJZkVtcHR5KHVuZGVmaW5lZClcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGlmIChjYW5jZWxhYmxlKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG5vdGlmaWVyJCA9IGRpc3BhdGNoZWQkLnBpcGUob2ZBY3Rpb25EaXNwYXRjaGVkKGFjdGlvbikpO1xuICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQucGlwZSh0YWtlVW50aWwobm90aWZpZXIkKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5waXBlKFxuICAgICAgICAgICAgICAvLyBOb3RlIHRoYXQgd2UgdXNlIHRoZSBgZmluYWxpemVgIG9wZXJhdG9yIG9ubHkgd2hlbiB0aGUgYWN0aW9uIGhhbmRsZXJcbiAgICAgICAgICAgICAgLy8gcmV0dXJucyBhbiBvYnNlcnZhYmxlLiBJZiB0aGUgYWN0aW9uIGhhbmRsZXIgaXMgc3luY2hyb25vdXMsIHdlIGRvIG5vdFxuICAgICAgICAgICAgICAvLyBuZWVkIHRvIHNldCB0aGUgc3RhdGUgY29udGV4dCBmdW5jdGlvbnMgdG8gYG5vb3BgLCBhcyB0aGUgYWJzZW5jZSBvZiBhXG4gICAgICAgICAgICAgIC8vIHJldHVybiB2YWx1ZSBpbmRpY2F0ZXMgbm8gYXN5bmNocm9ub3VzIGZ1bmN0aW9uYWxpdHkuIElmIHRoZSBoYW5kbGVyJ3NcbiAgICAgICAgICAgICAgLy8gcmVzdWx0IGlzIHVuc3Vic2NyaWJlZCAoZWl0aGVyIGJlY2F1c2UgdGhlIG9ic2VydmFibGUgaGFzIGNvbXBsZXRlZCBvciBpdFxuICAgICAgICAgICAgICAvLyB3YXMgdW5zdWJzY3JpYmVkIGJ5IGB0YWtlVW50aWxgIGR1ZSB0byBhIG5ldyBhY3Rpb24gYmVpbmcgZGlzcGF0Y2hlZCksXG4gICAgICAgICAgICAgIC8vIHdlIHByZXZlbnQgd3JpdGluZyB0byB0aGUgc3RhdGUgY29udGV4dC5cbiAgICAgICAgICAgICAgZmluYWxpemUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHN0YXRlQ29udGV4dC5zZXRTdGF0ZSA9IG5vb3A7XG4gICAgICAgICAgICAgICAgc3RhdGVDb250ZXh0LnBhdGNoU3RhdGUgPSBub29wO1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgdGhlIGFjdGlvbiBoYW5kbGVyIGlzIHN5bmNocm9ub3VzIGFuZCByZXR1cm5zIG5vdGhpbmcgKGB2b2lkYCksIHdlXG4gICAgICAgICAgICAvLyBzdGlsbCBoYXZlIHRvIGNvbnZlcnQgdGhlIHJlc3VsdCB0byBhIHN5bmNocm9ub3VzIG9ic2VydmFibGUuXG4gICAgICAgICAgICByZXN1bHQgPSBvZih1bmRlZmluZWQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICB9KTtcblxuICAgICAgZm9yIChjb25zdCBhY3Rpb25IYW5kbGVyIG9mIGFjdGlvbkhhbmRsZXJzKSB7XG4gICAgICAgIHRoaXMuX2FjdGlvblJlZ2lzdHJ5LnJlZ2lzdGVyKGFjdGlvblR5cGUsIGFjdGlvbkhhbmRsZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGlzIGlzIHVzZWQgdG8gcmVwbGFjZSBgc2V0U3RhdGVgIGFuZCBgcGF0Y2hTdGF0ZWAgb25jZSB0aGUgYWN0aW9uXG4vLyBoYW5kbGVyIGhhcyBiZWVuIHVuc3Vic2NyaWJlZCBvciBjb21wbGV0ZWQsIHRvIHByZXZlbnQgd3JpdGluZ1xuLy8gdG8gdGhlIHN0YXRlIGNvbnRleHQuXG5mdW5jdGlvbiBub29wKCkge31cbiJdfQ==