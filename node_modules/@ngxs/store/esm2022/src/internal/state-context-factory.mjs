import { Injectable } from '@angular/core';
import { getValue, setValue } from '@ngxs/store/plugins';
import { isStateOperator } from '@ngxs/store/operators';
import { InternalStateOperations } from '../internal/state-operations';
import { simplePatch } from './state-operators';
import * as i0 from "@angular/core";
import * as i1 from "../internal/state-operations";
/**
 * State Context factory class
 * @ignore
 */
export class StateContextFactory {
    constructor(_internalStateOperations) {
        this._internalStateOperations = _internalStateOperations;
    }
    /**
     * Create the state context
     */
    createStateContext(path) {
        const root = this._internalStateOperations.getRootStateOperations();
        return {
            getState() {
                const currentAppState = root.getState();
                return getState(currentAppState, path);
            },
            patchState(val) {
                const currentAppState = root.getState();
                const patchOperator = simplePatch(val);
                setStateFromOperator(root, currentAppState, patchOperator, path);
            },
            setState(val) {
                const currentAppState = root.getState();
                if (isStateOperator(val)) {
                    setStateFromOperator(root, currentAppState, val, path);
                }
                else {
                    setStateValue(root, currentAppState, val, path);
                }
            },
            dispatch(actions) {
                return root.dispatch(actions);
            }
        };
    }
    /** @nocollapse */ static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.6", ngImport: i0, type: StateContextFactory, deps: [{ token: i1.InternalStateOperations }], target: i0.ɵɵFactoryTarget.Injectable }); }
    /** @nocollapse */ static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.0.6", ngImport: i0, type: StateContextFactory, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.6", ngImport: i0, type: StateContextFactory, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: () => [{ type: i1.InternalStateOperations }] });
function setStateValue(root, currentAppState, newValue, path) {
    const newAppState = setValue(currentAppState, path, newValue);
    root.setState(newAppState);
    return newAppState;
    // In doing this refactoring I noticed that there is a 'bug' where the
    // application state is returned instead of this state slice.
    // This has worked this way since the beginning see:
    // https://github.com/ngxs/store/blame/324c667b4b7debd8eb979006c67ca0ae347d88cd/src/state-factory.ts
    // This needs to be fixed, but is a 'breaking' change.
    // I will do this fix in a subsequent PR and we can decide how to handle it.
}
function setStateFromOperator(root, currentAppState, stateOperator, path) {
    const local = getState(currentAppState, path);
    const newValue = stateOperator(local);
    return setStateValue(root, currentAppState, newValue, path);
}
function getState(currentAppState, path) {
    return getValue(currentAppState, path);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RhdGUtY29udGV4dC1mYWN0b3J5LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvc3RvcmUvc3JjL2ludGVybmFsL3N0YXRlLWNvbnRleHQtZmFjdG9yeS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzNDLE9BQU8sRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFDekQsT0FBTyxFQUFnQyxlQUFlLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUt0RixPQUFPLEVBQUUsdUJBQXVCLEVBQUUsTUFBTSw4QkFBOEIsQ0FBQztBQUN2RSxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sbUJBQW1CLENBQUM7OztBQUVoRDs7O0dBR0c7QUFFSCxNQUFNLE9BQU8sbUJBQW1CO0lBQzlCLFlBQW9CLHdCQUFpRDtRQUFqRCw2QkFBd0IsR0FBeEIsd0JBQXdCLENBQXlCO0lBQUcsQ0FBQztJQUV6RTs7T0FFRztJQUNILGtCQUFrQixDQUFJLElBQVk7UUFDaEMsTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLHdCQUF3QixDQUFDLHNCQUFzQixFQUFFLENBQUM7UUFFcEUsT0FBTztZQUNMLFFBQVE7Z0JBQ04sTUFBTSxlQUFlLEdBQUcsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO2dCQUN4QyxPQUFPLFFBQVEsQ0FBQyxlQUFlLEVBQUUsSUFBSSxDQUFDLENBQUM7WUFDekMsQ0FBQztZQUNELFVBQVUsQ0FBQyxHQUFlO2dCQUN4QixNQUFNLGVBQWUsR0FBRyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7Z0JBQ3hDLE1BQU0sYUFBYSxHQUFHLFdBQVcsQ0FBSSxHQUFHLENBQUMsQ0FBQztnQkFDMUMsb0JBQW9CLENBQUMsSUFBSSxFQUFFLGVBQWUsRUFBRSxhQUFhLEVBQUUsSUFBSSxDQUFDLENBQUM7WUFDbkUsQ0FBQztZQUNELFFBQVEsQ0FBQyxHQUF5QjtnQkFDaEMsTUFBTSxlQUFlLEdBQUcsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO2dCQUN4QyxJQUFJLGVBQWUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDO29CQUN6QixvQkFBb0IsQ0FBQyxJQUFJLEVBQUUsZUFBZSxFQUFFLEdBQUcsRUFBRSxJQUFJLENBQUMsQ0FBQztnQkFDekQsQ0FBQztxQkFBTSxDQUFDO29CQUNOLGFBQWEsQ0FBQyxJQUFJLEVBQUUsZUFBZSxFQUFFLEdBQUcsRUFBRSxJQUFJLENBQUMsQ0FBQztnQkFDbEQsQ0FBQztZQUNILENBQUM7WUFDRCxRQUFRLENBQUMsT0FBb0I7Z0JBQzNCLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUNoQyxDQUFDO1NBQ0YsQ0FBQztJQUNKLENBQUM7aUlBL0JVLG1CQUFtQjtxSUFBbkIsbUJBQW1CLGNBRE4sTUFBTTs7MkZBQ25CLG1CQUFtQjtrQkFEL0IsVUFBVTttQkFBQyxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUU7O0FBbUNsQyxTQUFTLGFBQWEsQ0FDcEIsSUFBMEIsRUFDMUIsZUFBb0IsRUFDcEIsUUFBVyxFQUNYLElBQVk7SUFFWixNQUFNLFdBQVcsR0FBRyxRQUFRLENBQUMsZUFBZSxFQUFFLElBQUksRUFBRSxRQUFRLENBQUMsQ0FBQztJQUM5RCxJQUFJLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBQzNCLE9BQU8sV0FBVyxDQUFDO0lBQ25CLHNFQUFzRTtJQUN0RSw2REFBNkQ7SUFDN0Qsb0RBQW9EO0lBQ3BELG9HQUFvRztJQUNwRyxzREFBc0Q7SUFDdEQsNEVBQTRFO0FBQzlFLENBQUM7QUFFRCxTQUFTLG9CQUFvQixDQUMzQixJQUEwQixFQUMxQixlQUFvQixFQUNwQixhQUErQixFQUMvQixJQUFZO0lBRVosTUFBTSxLQUFLLEdBQUcsUUFBUSxDQUFDLGVBQWUsRUFBRSxJQUFJLENBQUMsQ0FBQztJQUM5QyxNQUFNLFFBQVEsR0FBRyxhQUFhLENBQUMsS0FBeUIsQ0FBQyxDQUFDO0lBQzFELE9BQU8sYUFBYSxDQUFDLElBQUksRUFBRSxlQUFlLEVBQUUsUUFBUSxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQzlELENBQUM7QUFFRCxTQUFTLFFBQVEsQ0FBSSxlQUFvQixFQUFFLElBQVk7SUFDckQsT0FBTyxRQUFRLENBQUMsZUFBZSxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQ3pDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBnZXRWYWx1ZSwgc2V0VmFsdWUgfSBmcm9tICdAbmd4cy9zdG9yZS9wbHVnaW5zJztcbmltcG9ydCB7IEV4aXN0aW5nU3RhdGUsIFN0YXRlT3BlcmF0b3IsIGlzU3RhdGVPcGVyYXRvciB9IGZyb20gJ0BuZ3hzL3N0b3JlL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IFN0YXRlQ29udGV4dCB9IGZyb20gJy4uL3N5bWJvbHMnO1xuaW1wb3J0IHsgU3RhdGVPcGVyYXRpb25zIH0gZnJvbSAnLi4vaW50ZXJuYWwvaW50ZXJuYWxzJztcbmltcG9ydCB7IEludGVybmFsU3RhdGVPcGVyYXRpb25zIH0gZnJvbSAnLi4vaW50ZXJuYWwvc3RhdGUtb3BlcmF0aW9ucyc7XG5pbXBvcnQgeyBzaW1wbGVQYXRjaCB9IGZyb20gJy4vc3RhdGUtb3BlcmF0b3JzJztcblxuLyoqXG4gKiBTdGF0ZSBDb250ZXh0IGZhY3RvcnkgY2xhc3NcbiAqIEBpZ25vcmVcbiAqL1xuQEluamVjdGFibGUoeyBwcm92aWRlZEluOiAncm9vdCcgfSlcbmV4cG9ydCBjbGFzcyBTdGF0ZUNvbnRleHRGYWN0b3J5IHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfaW50ZXJuYWxTdGF0ZU9wZXJhdGlvbnM6IEludGVybmFsU3RhdGVPcGVyYXRpb25zKSB7fVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIHN0YXRlIGNvbnRleHRcbiAgICovXG4gIGNyZWF0ZVN0YXRlQ29udGV4dDxUPihwYXRoOiBzdHJpbmcpOiBTdGF0ZUNvbnRleHQ8VD4ge1xuICAgIGNvbnN0IHJvb3QgPSB0aGlzLl9pbnRlcm5hbFN0YXRlT3BlcmF0aW9ucy5nZXRSb290U3RhdGVPcGVyYXRpb25zKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgZ2V0U3RhdGUoKTogVCB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRBcHBTdGF0ZSA9IHJvb3QuZ2V0U3RhdGUoKTtcbiAgICAgICAgcmV0dXJuIGdldFN0YXRlKGN1cnJlbnRBcHBTdGF0ZSwgcGF0aCk7XG4gICAgICB9LFxuICAgICAgcGF0Y2hTdGF0ZSh2YWw6IFBhcnRpYWw8VD4pOiB2b2lkIHtcbiAgICAgICAgY29uc3QgY3VycmVudEFwcFN0YXRlID0gcm9vdC5nZXRTdGF0ZSgpO1xuICAgICAgICBjb25zdCBwYXRjaE9wZXJhdG9yID0gc2ltcGxlUGF0Y2g8VD4odmFsKTtcbiAgICAgICAgc2V0U3RhdGVGcm9tT3BlcmF0b3Iocm9vdCwgY3VycmVudEFwcFN0YXRlLCBwYXRjaE9wZXJhdG9yLCBwYXRoKTtcbiAgICAgIH0sXG4gICAgICBzZXRTdGF0ZSh2YWw6IFQgfCBTdGF0ZU9wZXJhdG9yPFQ+KTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRBcHBTdGF0ZSA9IHJvb3QuZ2V0U3RhdGUoKTtcbiAgICAgICAgaWYgKGlzU3RhdGVPcGVyYXRvcih2YWwpKSB7XG4gICAgICAgICAgc2V0U3RhdGVGcm9tT3BlcmF0b3Iocm9vdCwgY3VycmVudEFwcFN0YXRlLCB2YWwsIHBhdGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNldFN0YXRlVmFsdWUocm9vdCwgY3VycmVudEFwcFN0YXRlLCB2YWwsIHBhdGgpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGlzcGF0Y2goYWN0aW9uczogYW55IHwgYW55W10pOiBPYnNlcnZhYmxlPHZvaWQ+IHtcbiAgICAgICAgcmV0dXJuIHJvb3QuZGlzcGF0Y2goYWN0aW9ucyk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRTdGF0ZVZhbHVlPFQ+KFxuICByb290OiBTdGF0ZU9wZXJhdGlvbnM8YW55PixcbiAgY3VycmVudEFwcFN0YXRlOiBhbnksXG4gIG5ld1ZhbHVlOiBULFxuICBwYXRoOiBzdHJpbmdcbik6IGFueSB7XG4gIGNvbnN0IG5ld0FwcFN0YXRlID0gc2V0VmFsdWUoY3VycmVudEFwcFN0YXRlLCBwYXRoLCBuZXdWYWx1ZSk7XG4gIHJvb3Quc2V0U3RhdGUobmV3QXBwU3RhdGUpO1xuICByZXR1cm4gbmV3QXBwU3RhdGU7XG4gIC8vIEluIGRvaW5nIHRoaXMgcmVmYWN0b3JpbmcgSSBub3RpY2VkIHRoYXQgdGhlcmUgaXMgYSAnYnVnJyB3aGVyZSB0aGVcbiAgLy8gYXBwbGljYXRpb24gc3RhdGUgaXMgcmV0dXJuZWQgaW5zdGVhZCBvZiB0aGlzIHN0YXRlIHNsaWNlLlxuICAvLyBUaGlzIGhhcyB3b3JrZWQgdGhpcyB3YXkgc2luY2UgdGhlIGJlZ2lubmluZyBzZWU6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9uZ3hzL3N0b3JlL2JsYW1lLzMyNGM2NjdiNGI3ZGViZDhlYjk3OTAwNmM2N2NhMGFlMzQ3ZDg4Y2Qvc3JjL3N0YXRlLWZhY3RvcnkudHNcbiAgLy8gVGhpcyBuZWVkcyB0byBiZSBmaXhlZCwgYnV0IGlzIGEgJ2JyZWFraW5nJyBjaGFuZ2UuXG4gIC8vIEkgd2lsbCBkbyB0aGlzIGZpeCBpbiBhIHN1YnNlcXVlbnQgUFIgYW5kIHdlIGNhbiBkZWNpZGUgaG93IHRvIGhhbmRsZSBpdC5cbn1cblxuZnVuY3Rpb24gc2V0U3RhdGVGcm9tT3BlcmF0b3I8VD4oXG4gIHJvb3Q6IFN0YXRlT3BlcmF0aW9uczxhbnk+LFxuICBjdXJyZW50QXBwU3RhdGU6IGFueSxcbiAgc3RhdGVPcGVyYXRvcjogU3RhdGVPcGVyYXRvcjxUPixcbiAgcGF0aDogc3RyaW5nXG4pIHtcbiAgY29uc3QgbG9jYWwgPSBnZXRTdGF0ZShjdXJyZW50QXBwU3RhdGUsIHBhdGgpO1xuICBjb25zdCBuZXdWYWx1ZSA9IHN0YXRlT3BlcmF0b3IobG9jYWwgYXMgRXhpc3RpbmdTdGF0ZTxUPik7XG4gIHJldHVybiBzZXRTdGF0ZVZhbHVlKHJvb3QsIGN1cnJlbnRBcHBTdGF0ZSwgbmV3VmFsdWUsIHBhdGgpO1xufVxuXG5mdW5jdGlvbiBnZXRTdGF0ZTxUPihjdXJyZW50QXBwU3RhdGU6IGFueSwgcGF0aDogc3RyaW5nKTogVCB7XG4gIHJldHVybiBnZXRWYWx1ZShjdXJyZW50QXBwU3RhdGUsIHBhdGgpO1xufVxuIl19