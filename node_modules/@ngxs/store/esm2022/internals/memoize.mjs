function areArgumentsShallowlyEqual(equalityCheck, prev, next) {
    if (prev === null || next === null || prev.length !== next.length) {
        return false;
    }
    // Do this in a for loop (and not a `forEach` or an `every`) so we can
    // determine equality as fast as possible.
    const length = prev.length;
    for (let i = 0; i < length; i++) {
        if (!equalityCheck(prev[i], next[i])) {
            return false;
        }
    }
    return true;
}
/**
 * Memoize a function on its last inputs only.
 * Originally from: https://github.com/reduxjs/reselect/blob/master/src/index.js
 *
 * @ignore
 */
export function Éµmemoize(func, equalityCheck = Object.is) {
    let lastArgs = null;
    let lastResult = null;
    // we reference arguments instead of spreading them for performance reasons
    function memoized() {
        // eslint-disable-next-line prefer-rest-params
        if (!areArgumentsShallowlyEqual(equalityCheck, lastArgs, arguments)) {
            // apply arguments instead of spreading for performance.
            // eslint-disable-next-line prefer-rest-params, prefer-spread
            lastResult = func.apply(null, arguments);
        }
        // eslint-disable-next-line prefer-rest-params
        lastArgs = arguments;
        return lastResult;
    }
    memoized.reset = function () {
        // The hidden (for now) ability to reset the memoization
        lastArgs = null;
        lastResult = null;
    };
    return memoized;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWVtb2l6ZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3BhY2thZ2VzL3N0b3JlL2ludGVybmFscy9zcmMvbWVtb2l6ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxTQUFTLDBCQUEwQixDQUNqQyxhQUEwQyxFQUMxQyxJQUF1QixFQUN2QixJQUF1QjtJQUV2QixJQUFJLElBQUksS0FBSyxJQUFJLElBQUksSUFBSSxLQUFLLElBQUksSUFBSSxJQUFJLENBQUMsTUFBTSxLQUFLLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQztRQUNsRSxPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7SUFFRCxzRUFBc0U7SUFDdEUsMENBQTBDO0lBQzFDLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUM7SUFDM0IsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDO1FBQ2hDLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7WUFDckMsT0FBTyxLQUFLLENBQUM7UUFDZixDQUFDO0lBQ0gsQ0FBQztJQUVELE9BQU8sSUFBSSxDQUFDO0FBQ2QsQ0FBQztBQUVEOzs7OztHQUtHO0FBQ0gsTUFBTSxVQUFVLFFBQVEsQ0FDdEIsSUFBTyxFQUNQLGFBQWEsR0FBRyxNQUFNLENBQUMsRUFBRTtJQUV6QixJQUFJLFFBQVEsR0FBc0IsSUFBSSxDQUFDO0lBQ3ZDLElBQUksVUFBVSxHQUFRLElBQUksQ0FBQztJQUMzQiwyRUFBMkU7SUFDM0UsU0FBUyxRQUFRO1FBQ2YsOENBQThDO1FBQzlDLElBQUksQ0FBQywwQkFBMEIsQ0FBQyxhQUFhLEVBQUUsUUFBUSxFQUFFLFNBQVMsQ0FBQyxFQUFFLENBQUM7WUFDcEUsd0RBQXdEO1lBQ3hELDZEQUE2RDtZQUM3RCxVQUFVLEdBQWMsSUFBSyxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7UUFDdkQsQ0FBQztRQUNELDhDQUE4QztRQUM5QyxRQUFRLEdBQUcsU0FBUyxDQUFDO1FBQ3JCLE9BQU8sVUFBVSxDQUFDO0lBQ3BCLENBQUM7SUFDSyxRQUFTLENBQUMsS0FBSyxHQUFHO1FBQ3RCLHdEQUF3RDtRQUN4RCxRQUFRLEdBQUcsSUFBSSxDQUFDO1FBQ2hCLFVBQVUsR0FBRyxJQUFJLENBQUM7SUFDcEIsQ0FBQyxDQUFDO0lBQ0YsT0FBTyxRQUFhLENBQUM7QUFDdkIsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGFyZUFyZ3VtZW50c1NoYWxsb3dseUVxdWFsKFxuICBlcXVhbGl0eUNoZWNrOiAoYTogYW55LCBiOiBhbnkpID0+IGJvb2xlYW4sXG4gIHByZXY6IElBcmd1bWVudHMgfCBudWxsLFxuICBuZXh0OiBJQXJndW1lbnRzIHwgbnVsbFxuKSB7XG4gIGlmIChwcmV2ID09PSBudWxsIHx8IG5leHQgPT09IG51bGwgfHwgcHJldi5sZW5ndGggIT09IG5leHQubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gRG8gdGhpcyBpbiBhIGZvciBsb29wIChhbmQgbm90IGEgYGZvckVhY2hgIG9yIGFuIGBldmVyeWApIHNvIHdlIGNhblxuICAvLyBkZXRlcm1pbmUgZXF1YWxpdHkgYXMgZmFzdCBhcyBwb3NzaWJsZS5cbiAgY29uc3QgbGVuZ3RoID0gcHJldi5sZW5ndGg7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIWVxdWFsaXR5Q2hlY2socHJldltpXSwgbmV4dFtpXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBNZW1vaXplIGEgZnVuY3Rpb24gb24gaXRzIGxhc3QgaW5wdXRzIG9ubHkuXG4gKiBPcmlnaW5hbGx5IGZyb206IGh0dHBzOi8vZ2l0aHViLmNvbS9yZWR1eGpzL3Jlc2VsZWN0L2Jsb2IvbWFzdGVyL3NyYy9pbmRleC5qc1xuICpcbiAqIEBpZ25vcmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIMm1bWVtb2l6ZTxUIGV4dGVuZHMgKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnk+KFxuICBmdW5jOiBULFxuICBlcXVhbGl0eUNoZWNrID0gT2JqZWN0LmlzXG4pOiBUIHtcbiAgbGV0IGxhc3RBcmdzOiBJQXJndW1lbnRzIHwgbnVsbCA9IG51bGw7XG4gIGxldCBsYXN0UmVzdWx0OiBhbnkgPSBudWxsO1xuICAvLyB3ZSByZWZlcmVuY2UgYXJndW1lbnRzIGluc3RlYWQgb2Ygc3ByZWFkaW5nIHRoZW0gZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnNcbiAgZnVuY3Rpb24gbWVtb2l6ZWQoKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1yZXN0LXBhcmFtc1xuICAgIGlmICghYXJlQXJndW1lbnRzU2hhbGxvd2x5RXF1YWwoZXF1YWxpdHlDaGVjaywgbGFzdEFyZ3MsIGFyZ3VtZW50cykpIHtcbiAgICAgIC8vIGFwcGx5IGFyZ3VtZW50cyBpbnN0ZWFkIG9mIHNwcmVhZGluZyBmb3IgcGVyZm9ybWFuY2UuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLXJlc3QtcGFyYW1zLCBwcmVmZXItc3ByZWFkXG4gICAgICBsYXN0UmVzdWx0ID0gKDxGdW5jdGlvbj5mdW5jKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLXJlc3QtcGFyYW1zXG4gICAgbGFzdEFyZ3MgPSBhcmd1bWVudHM7XG4gICAgcmV0dXJuIGxhc3RSZXN1bHQ7XG4gIH1cbiAgKDxhbnk+bWVtb2l6ZWQpLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIFRoZSBoaWRkZW4gKGZvciBub3cpIGFiaWxpdHkgdG8gcmVzZXQgdGhlIG1lbW9pemF0aW9uXG4gICAgbGFzdEFyZ3MgPSBudWxsO1xuICAgIGxhc3RSZXN1bHQgPSBudWxsO1xuICB9O1xuICByZXR1cm4gbWVtb2l6ZWQgYXMgVDtcbn1cbiJdfQ==