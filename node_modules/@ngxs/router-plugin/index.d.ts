import * as i0 from '@angular/core';
import { ModuleWithProviders, EnvironmentProviders, OnDestroy, NgZone, Injector } from '@angular/core';
import { NgxsRouterPluginOptions } from '@ngxs/router-plugin/internals';
export { NavigationActionTiming, NgxsRouterPluginOptions } from '@ngxs/router-plugin/internals';
import * as i1 from '@ngxs/store';
import { StateToken, Store, StateContext } from '@ngxs/store';
import { Params, NavigationExtras, RouterStateSnapshot, NavigationStart, RoutesRecognized, NavigationCancel, NavigationError, ResolveEnd, NavigationEnd, ActivatedRouteSnapshot, Router } from '@angular/router';

declare class NgxsRouterPluginModule {
    static forRoot(options?: NgxsRouterPluginOptions): ModuleWithProviders<NgxsRouterPluginModule>;
    static ɵfac: i0.ɵɵFactoryDeclaration<NgxsRouterPluginModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<NgxsRouterPluginModule, never, [typeof i1.ɵNgxsFeatureModule], never>;
    static ɵinj: i0.ɵɵInjectorDeclaration<NgxsRouterPluginModule>;
}
declare function withNgxsRouterPlugin(options?: NgxsRouterPluginOptions): EnvironmentProviders;

/**
 * Public event api of the router
 */
declare class Navigate {
    path: any[];
    queryParams?: Params | undefined;
    extras?: NavigationExtras | undefined;
    static readonly type = "[Router] Navigate";
    constructor(path: any[], queryParams?: Params | undefined, extras?: NavigationExtras | undefined);
}
/**
 *
 * Angular Routers internal state events
 *
 */
/**
 * An action dispatched when the router starts the navigation.
 */
declare class RouterRequest<T = RouterStateSnapshot> {
    routerState: T;
    event: NavigationStart;
    trigger: RouterTrigger;
    static readonly type = "[Router] RouterRequest";
    constructor(routerState: T, event: NavigationStart, trigger?: RouterTrigger);
}
/**
 * An action dispatched when the router navigates.
 */
declare class RouterNavigation<T = RouterStateSnapshot> {
    routerState: T;
    event: RoutesRecognized;
    trigger: RouterTrigger;
    static readonly type = "[Router] RouterNavigation";
    constructor(routerState: T, event: RoutesRecognized, trigger?: RouterTrigger);
}
/**
 * An action dispatched when the router cancel navigation.
 */
declare class RouterCancel<T, V = RouterStateSnapshot> {
    routerState: V;
    storeState: T;
    event: NavigationCancel;
    trigger: RouterTrigger;
    static readonly type = "[Router] RouterCancel";
    constructor(routerState: V, storeState: T, event: NavigationCancel, trigger?: RouterTrigger);
}
/**
 * An action dispatched when the router errors.
 */
declare class RouterError<T, V = RouterStateSnapshot> {
    routerState: V;
    storeState: T;
    event: NavigationError;
    trigger: RouterTrigger;
    static readonly type = "[Router] RouterError";
    constructor(routerState: V, storeState: T, event: NavigationError, trigger?: RouterTrigger);
}
/**
 * An action dispatched when the `ResolveEnd` event is triggered.
 */
declare class RouterDataResolved<T = RouterStateSnapshot> {
    routerState: T;
    event: ResolveEnd;
    trigger: RouterTrigger;
    static readonly type = "[Router] RouterDataResolved";
    constructor(routerState: T, event: ResolveEnd, trigger?: RouterTrigger);
}
/**
 * An action dispatched when the router navigation has been finished successfully.
 */
declare class RouterNavigated<T = RouterStateSnapshot> {
    routerState: T;
    event: NavigationEnd;
    trigger: RouterTrigger;
    static readonly type = "[Router] RouterNavigated";
    constructor(routerState: T, event: NavigationEnd, trigger?: RouterTrigger);
}
/**
 * An union type of router actions.
 */
type RouterAction<T, V = RouterStateSnapshot> = RouterRequest<V> | RouterNavigation<V> | RouterCancel<T, V> | RouterError<T, V> | RouterDataResolved<V> | RouterNavigated<V>;

declare abstract class RouterStateSerializer<T> {
    abstract serialize(routerState: RouterStateSnapshot): T;
}
interface SerializedRouterStateSnapshot {
    root: ActivatedRouteSnapshot;
    url: string;
}
declare class DefaultRouterStateSerializer implements RouterStateSerializer<SerializedRouterStateSnapshot> {
    serialize(routerState: RouterStateSnapshot): SerializedRouterStateSnapshot;
    private serializeRoute;
}

interface RouterStateModel<T = RouterStateSnapshot> {
    state?: T;
    navigationId?: number;
    trigger: RouterTrigger;
}
type RouterTrigger = 'none' | 'router' | 'store' | 'devtools';
declare const ROUTER_STATE_TOKEN: StateToken<RouterStateModel<RouterStateSnapshot>>;
declare class RouterState implements OnDestroy {
    private _store;
    private _router;
    private _serializer;
    private _ngZone;
    /**
     * Determines how navigation was performed by the `RouterState` itself
     * or outside via `new Navigate(...)`
     */
    private _trigger;
    /**
     * That's the serialized state from the `Router` class
     */
    private _routerState;
    /**
     * That's the value of the `RouterState` state
     */
    private _storeState;
    private _lastEvent;
    private _options;
    private _destroy$;
    static state: (state: RouterStateModel<RouterStateSnapshot>) => RouterStateSnapshot | undefined;
    static url: (state: RouterStateModel<RouterStateSnapshot>) => string | undefined;
    constructor(_store: Store, _router: Router, _serializer: RouterStateSerializer<RouterStateSnapshot>, _ngZone: NgZone, injector: Injector);
    ngOnDestroy(): void;
    navigate(_: StateContext<RouterStateModel>, action: Navigate): Promise<boolean>;
    angularRouterAction(ctx: StateContext<RouterStateModel>, action: RouterAction<RouterStateModel, RouterStateSnapshot>): void;
    private _setUpStoreListener;
    private _navigateIfNeeded;
    private _setUpRouterEventsListener;
    /** Reacts to `NavigationStart`. */
    private _navigationStart;
    /** Reacts to `ResolveEnd`. */
    private _dispatchRouterDataResolved;
    /** Reacts to `RoutesRecognized` or `NavigationEnd`, depends on the `navigationActionTiming`. */
    private _dispatchRouterNavigation;
    /** Reacts to `NavigationCancel`. */
    private _dispatchRouterCancel;
    /** Reacts to `NavigationEnd`. */
    private _dispatchRouterError;
    /** Reacts to `NavigationEnd`. */
    private _dispatchRouterNavigated;
    private _dispatchRouterAction;
    private _reset;
    static ɵfac: i0.ɵɵFactoryDeclaration<RouterState, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<RouterState>;
}

export { DefaultRouterStateSerializer, Navigate, NgxsRouterPluginModule, ROUTER_STATE_TOKEN, type RouterAction, RouterCancel, RouterDataResolved, RouterError, RouterNavigated, RouterNavigation, RouterRequest, RouterState, type RouterStateModel, RouterStateSerializer, type SerializedRouterStateSnapshot, withNgxsRouterPlugin };
